<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用RSA对参数签名]]></title>
    <url>%2F2017%2F09%2F26%2F%E4%BD%BF%E7%94%A8RSA%E5%AF%B9%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[导论记录最近使用最多的RSA签名加密。由于所在行业安全要求比较高，请求的参数都是加密过后再使用的，使用的是RSA加密算法。需要请求方讲参数使用私钥加密，处理方获取到参数后需要使用公钥验签，通过再处理业务逻辑，这是最简单的加密和解密。 笔者使用的是OpenSSL工具生成的公钥和私钥暂存文件，签名和验签使用的是jdk自行支持的签名算法。 正文使用OpenSSL先生成公钥和私钥的暂存文件首先下载OpenSSL的工具类，搞完之后直接执行指令之后即可。参考地址 执行指令如下图: 执行之后会生成三个pem文件： rsa_public_key.pem：公钥文件rsa_private_key.pem：私钥文件rsa_private_key_pkcs8.pem：pkc格式的私钥文件，java专用。 所有的准备工作都ok了，接下来来测试 测试测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mxl.rsa.demo;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SignatureException;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import org.junit.Test;/** * * @author MXL * */public class TestSign &#123; private static final String PRIVATE_PATH = &quot;rsa_private_key_pkcs8.pem&quot;; private static final String PUBLIC_PATH = &quot;rsa_public_key.pem&quot;; @Test public void testSign() throws InvalidKeyException, NoSuchAlgorithmException, SignatureException&#123; //获取私钥路径 String privateKeyFile = TestSign.class.getClassLoader().getResource(&quot;&quot;).getPath() + PRIVATE_PATH; //获取公钥路径 String publicKeyFile = TestSign.class.getClassLoader().getResource(&quot;&quot;).getPath() + PUBLIC_PATH; privateKeyFile = privateKeyFile.replaceAll(&quot;%20&quot;, &quot; &quot;); publicKeyFile = publicKeyFile.replaceAll(&quot;%20&quot;, &quot; &quot;); //使用JDK自带的方式获取私钥 RSAPrivateKey rsaPrivateKey = RSAUtils.initPemPrivateKey(privateKeyFile); //公钥获取 RSAPublicKey rsaPublicKey = RSAUtils.initPemPublicKey(publicKeyFile); //构造签名内容 String signData = &quot;Hello RSA&quot;; //使用私钥签名 byte[] signature = RSAUtils.sign(rsaPrivateKey, signData.getBytes()); if(RSAUtils.verifySignature(rsaPublicKey, signData.getBytes(), signature))&#123; System.out.println(&quot;验签成功，是自己人&quot;); &#125;else &#123; System.out.println(&quot;验签失败&quot;); &#125; &#125; &#125;outPut：验签成功，是自己人 代码每一行都加了注释，很好理解，下面来看看RSAUtils中的内容。 获取私钥123456789101112131415161718192021222324252627282930public static RSAPrivateKey initPemPrivateKey(String privateKeyFile) &#123; BufferedReader br = null; try &#123; br = new BufferedReader(new FileReader(privateKeyFile)); String s = br.readLine(); StringBuffer privatekey = new StringBuffer(); s = br.readLine(); while (s.charAt(0) != &apos;-&apos;) &#123; privatekey.append(s + &quot;\r&quot;); s = br.readLine(); &#125; byte[] keybyte = new BASE64Decoder().decodeBuffer(privatekey.toString()); KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keybyte); return (RSAPrivateKey)kf.generatePrivate(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; if(br!=null) br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null;&#125; 代码好理解，这里不废话了，获取公钥也是类似 签名1234567public static byte[] sign(RSAPrivateKey privateKey, byte[] b) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; Signature sig = Signature.getInstance(&quot;SHA1withRSA&quot;); sig.initSign(privateKey); sig.update(b); byte[] signature = sig.sign(); return signature;&#125; 验签1234567public static boolean verifySignature(RSAPublicKey publicKey, byte[] data, byte[] signature) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; Signature sig2 = Signature.getInstance(&quot;SHA1withRSA&quot;); sig2.initVerify(publicKey); sig2.update(data); return sig2.verify(signature);&#125; 总结参数加密在支付和javaCard中使用的是很频繁的，记录归档，方便复习。另外在网上看到一句不错的总结：私钥加密，公钥解密；私钥签名，公钥验签。]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1988,我想和这个世界谈谈 摘录]]></title>
    <url>%2F2017%2F09%2F20%2F%E3%80%8A1988%2C%E6%88%91%E6%83%B3%E5%92%8C%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E8%B0%88%E8%B0%88%E3%80%8B%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一、导论很久没有更新博客了，今天不写技术博客，记录一下自己对韩寒的《1988，我想和这个世界谈谈》的感受。（部分内容摘自网络） 1988最好的地方不是那些隐喻，而是在于它描写了一个非真实的中国社会。当代的中国作家，要么是流连于北上广大城市的写字楼、格子间，要么是沉醉于校园的白衣飘飘、凤凰花开，要么是追忆历史洪流、牛棚杂记，要么就是盗墓灵异、科幻悬疑，但很少人写当下中国广泛存在的三四线城镇人们的那种混沌、灰暗、麻木的生活状态。 这才是中国城市的最常态。但其实，这也不是韩寒真正想写的，1988主要是为了向一些人致敬，那些有热血的、活泼的、生命力旺盛的人，那些改变自己的命运，虽然被现实一把盖住锅盖，但还在沸水淹没之前咚咚地跳动的人。 其实，以上这些在我心里也并不重要，1988最打动我的是它描写了一个史上最动人的妓女——娜娜。这个普通的、生动的、让人心疼的女孩子，我为她流过好几次泪，看一次流一次。 二、正文1、1988的涵义 我和朋友在路边看见了1988，那时候它只有一个壳子和车架。 朋友说，他以前待的厂里有一台一样的撞报废的车，很多零件可以用，再买一些就能拼成一台能开的车。只需要这个数目，他伸出了手掌。 我问他，那这个车的手续怎么办？ 朋友说，可以用那辆撞报废的车的手续。 我说，车主会答应么？朋友说，死了。我说，车主的亲戚也不会答应的。朋友说，都在那车里死光了。我说，那是不是不道德？ 电脑自动打字如下：1988这台车其实是暗喻中国，“只有一壳子和车架的车”是指1949年以前的中国，满目疮痍，百废待兴，而“有一台一样的撞报废的车”指的是国民党统治的中国，“车的手续”就是中国这个名义，“车主”指的是国民党车主的亲戚”大概是美国吧，说他们都在车里死光了并不是说他们灭亡了，而是说他们失去了对中国的控制权。 2、警察抓嫖 突然间，房门被踹开了，踹房门的力量如此之大，门框的木屑都飞到了窗帘上。门撞到了墙壁上又反弹了回去，门口传来一声哎呀。我还在想是哪个服务员这么豪放，至少有十个人破门而入。我都未及仔细看，被此起彼伏的“站住”“抓住了”“干什么”所包围，我早已经一动不动，周围的人还在源源不断地向我压来，我被第一个人反剪了手，脸被不知道谁的手按在地上，还有三只手掐着我的脖子，一个人的膝盖直接跪在我的腰上，两条腿分别被两个人按着，但是我感觉至少还有三个人要从人堆里插进来。我觉得很内疚，因为我身上已经没有什么部位可以供给他们制服，从他们进来的第一秒钟开始，我已经一动都不能动，但是他们却在我的身上不断地涌动，并且不断地大喊，不许动。 想起来了吧？韩寒曾经分享过的一个视频前扑后继_韩寒我只能说，韩寒你真是活学活用小能手，而且你说得对，写博客真的会削减作者的写作素材。 3、墨绿色铁门的校办工厂 在那个校办厂里，始终紧闭着大门，那些人还在全神贯注的工作，有一个人抬头看到了，马上又低下头去打磨他的零件。在这样重大的群体性事件中，他们还能保持这样的工作，他们究竟在干什么？ 这个校办厂是一个兵工厂，至于为什么这个兵工厂在那个时期非常紧张地在生产武器，我认为可能是因为在80年代的最后一年，中国出现了大面积的思想震荡，dang为了维稳，加紧制造武器，以防变天（我是历史渣，不同意可以讨论）。还有一种说法，这是一个无政府组织在制造武器，可能是《光荣日》中麦大麦他们一伙干的那种事 ，也许丁丁哥哥也是他们的一员。 4、我一个人去儿童乐园里走了走，用步伐度量了一下，长四十八步，宽二十步 48×20=960 960万平方公里……我是不是想多了？ 5、一辆海狮面包车开了出来，里面应该是坐着很高的领导。他打了一个右转向灯，结果却左转了。 让人宽慰的是，看到上文，我本以为要实行“一枪枪毙”，但这仅仅是“一票否决”，比毛泽东那会儿进步多了。至于一票什么样的人能投出这一票，我并不关心，我关心的是这个方针政策和基本理论实在很难把握，当权者在要求我们统一思想的时候，自己经常统一不了思想，在我幼小的记忆中，我隐约记得我的高中课本里讲到三权分立，政治课本和政治老师都说，三权分立是个好东西，但最近我一直看到官方的文章和讲话，说三权分立是错误思想。你知道我是一个只有高中文凭的人，我的政治课学到这里就退学了，我只觉得很困惑，我为那些散布过这个错误思想的政治老师和教材编委的命运感到担忧。他们一直在念着领导给的稿子，弄不好还要还给领导办了，原因是那稿子是领导昨天晚上的想法，今天领导起床以后想法变了。对于这种感受，我看到过一个精确的评价，大意是……他上了车，马上打开右转向灯，往前开了一米，结果他左转了，左转也就算了，没想到他居然调了一个头。所以，被这样的司机撞死只能自认倒霉。 韩寒是个没什么城府的人，他看到什么、想到什么就会跟读者分享什么，所以读者应该格外珍惜这样的作者，他在自己最珍视的小说里跟你分享他的真实想法，读者应该看得更认真一点。 6、关于目的地整本1988我最无法解释清楚的就是“我”即陆子野旅行的目的。关于陆子野的整个旅程，初看起来像是要去接他的朋友从监狱出来。但是文中不止一次提到旅途的终点是318国道的尽头，文中有一句： 我要从这里出发，沿着 318号国道，开到那里的尽头。……我要去向我的目的地。我要去那里支援我的兄弟们。 众所周知，318号国道的尽头是西藏聂拉木县的友谊桥，而他的朋友关押的地方，是一座有着“潮湿而迷宫般的道路”的“江城”，娜娜也是在这里消失的。我认为这座城市可能是重庆，说起重庆就会自动脑补很多事情了。我们可以猜测这个朋友是打黑除恶进去的或者是冤案进去的，但并没有什么确凿的证据。但既然是江城，那么前面说要开到318国道的尽头又是怎么回事？去支援我的兄弟们又是怎么回事？韩寒是不是写着写着又忘了？看着也不像，因为结尾的时候“我”真的去了318国道尽头，等了一整天，也许是赴刘茵茵的十年之约（虽然她已经死了）。 7、关于流沙和植物 这么多年来，一直是我脚下的流沙裹着我四处漂泊，它也不淹没我，它只是时不时提醒我，你没有别的选择，否则你就被风吹走了。我就这么浑浑噩噩地度过了我所有热血的岁月，被裹到东，被裹到西，连我曾经所鄙视的种子都不如。一直到一周以前，我对流沙说，让风把我吹走吧。 流沙说，你没了根，马上就死。 我说，我存够了水，能活一阵子。 流沙说，但是风会把你无休止的留在空中，你就脱水了。 我说，我还有雨水。 流沙说，雨水要流到大地上，才能够积蓄成水塘，它在空中的时候，只是一个装饰品。 我说，我会掉到水塘里的。 流沙说，那你就淹死了。 我说，让我试试吧。 流沙说，我把你拱到小沙丘上，你低头看看，多少像你这样的植物，都是依附着我们。 我说，有种你就把我抬得更高一点，让我看看普天下所有的植物，是不是都是像我们这样生活着。 流沙说，你怎么能反抗我。我要吞没你。 我说，那我就让西风带走我。 于是我毅然往上一挣扎，其实也没有费力。我离开了流沙，往脚底下一看，操，原来我不是一个植物，我是一只动物，这帮孙子骗了我二十多年。作为一个有脚的动物，我终于可以决定我的去向。我回头看了流沙一眼，流沙说，你走吧，别告诉别的植物其实他们是动物。 这段很明显是有寓意的，而且可以延伸开去，做更多的解释。第一层最明显的涵义就是韩寒在讽喻他退学的事情，流沙就是指教育体制，植物就是指依附于教育体制的学生或老师。这段对话跟他退学时跟老师的对话何其相似。第二层涵义就不单单指教育体制了，而是指更宽泛的所谓“体制内”的那个体制，植物挣脱流沙就是体制内人士要挣脱体制的过程。第三层就更加深入了，韩寒在2013年9月还在微博重新发了这一段，并说“和朋友们共勉，在这坏天气里。”结合当时的环境来看大有深意，那段时间发生了一系列事件，正值当今圣上登基不久，数位知名大V相继被捕，夏俊峰被执行了死刑等，政策环境看似宽松实则收紧，这大概就是韩寒所说的“坏天气”吧。基于这层意思，流沙就可以理解为当局，挣脱当局的管制有什么途径，可以自己想想。 8、袭击化工厂 娜娜开始延伸这个故事，问道，你朋友怎么进去了。 我说，他袭击了化工厂。 娜娜问，谁是化工厂啊？哦，是化工厂啊，他袭击化工厂干什么？ 我说，这个事情挺长的，我以后和你说吧，你先给你的那个先生发短信。 这里这个朋友应该是在调侃左小祖咒，不知道有多少人知道左小祖咒曾经因被怀疑是东方化工厂爆炸的嫌疑犯，被关押在昌平收容所二十多天这个事情。 9、打弹子 他要打别人的时候就换大弹子，别人打他的时候就换成小弹子，他每天都要赢走我们二三十颗弹子。但是我们躲不了他，因为能打弹子的泥地就那么几块。 很简单，这里是讽刺官方的双重标准和垄断。 10 号出来主持局面，说一切都是因为他的英勇，而且他是双料圣斗士，所以他先选。然后是我们四个人。出于公平，我们先数了弹子，一共四百七十二粒，没有想到他赢了我们那么多。10 号挑走了一百五十粒，我不记得他们拿走了多少，我最后得到了三十多粒。我记得我明明是输给临时工哥哥最多的那个人。他要开始打的时候，我万万没有想到，他从兜里掏出了一粒大弹子。他缓缓的用他的大弹子击中了我的那粒，我血液翻腾，不假思索，拾起他的大弹子就吞了。 很明显，这里是讽刺老百姓当了权一样操蛋。 10、丁丁哥哥的死。 我没有意识到，那一刻是丁丁哥哥在唱歌，这是我第一次听他唱歌，但是我却打断了他，丁丁哥哥看着我说，漫漫长路，起伏不能由我。我跟着唱道，漫漫长路，起伏不能由我。丁丁哥哥说，这是去年的歌，今年唱着还挺有感觉。我跟着说，挺有感觉！ 这首歌是《尘缘》，电视剧《八月桂花香》的主题曲，从百度百科查到这部电视剧的出品时间1988年，播出时间1988年。”去年“是1988年，那么”今年“当然就是1989年。 文中写了，唱完这首歌，丁丁哥哥就收拾行囊去了北方 丁丁哥哥在春天收拾好所有的行囊，握着一张火车票向我告别。 我说，丁丁哥哥，你要去南方还是要去北方啊。 丁丁哥哥说，我要去北方。 我说，哇，带我一起去吧。 丁丁哥哥说，不行，你太小了。 我说，我坐火车不用钱的。 丁丁哥哥说，不行，你太大了。 我说，丁丁哥哥，你去做什么啊？ 丁丁哥哥说，我去和他们谈谈。 我说，你和谁谈谈啊？ 丁丁哥哥唇边露出微笑，急切地说，这个世界。 我说，哇噢。 1989年的春天丁丁哥哥去了北方要去跟他们谈谈，后来就死了。不言自明。 丁丁哥哥死后，又给出两个很明显的提示 一是： 丁丁哥哥若是活着应该是38岁？39岁？40岁？ 《1988我想和这个世界谈谈》这本书是2010年出版的，如果算丁丁哥哥是19岁上大一的话，到2010年他应该已经40岁了。二是： 但我一定要等到夏天，我一定要知道这几个女孩子究竟谁是我爱上的那个身影。我听着小虎队 1989 年的磁带入眠，那盘《男孩不哭》被我 A 面 B 面反复聆听。…… 在迎接夏天来临时听着小虎队1989年的磁带，这就更不用说了。 11、娜娜的去向。 从书中医生的反应来看，娜娜是不幸感染了艾滋病，但是她还是把肚子里的孩子生下来了，并在死前托人把孩子送给陆子野。可以想见，她没有找到孙老板，也没有找到孩子的亲生父亲，即便找到，他们也不会接纳她这样一个身染艾滋的怀孕的妓女。有人认为娜娜还活着，但是我认为，娜娜一定是死了，若她在世，以她对孩子的强烈的爱，她是不会把孩子送人的，只有她要离开人世才不得不把孩子托付给别人，唯一一个值得信任的陌生人。她特意托人跟他说“放心吧，给你的，都是好的”，这跟他们见面谈价钱时说的那句话是一样的，首尾呼应。这句话说明这孩子并没有感染上艾滋病，她带着娜娜对她的期望，纯洁地降临在人世间，就像娜的重生。 在书的结尾，陆子野终于到了318号国道的尽头，去赴刘茵茵的十年之约，我觉得这一刻他也同时在等娜娜，只是他知道她不会再出现了。 站在我故乡那条国道尽头的友谊桥上， 在稀薄的空气里，从凌晨开始等待，我从不凝望过往的每一台汽车。1988 的点烟器烧坏了，我向一个路过的司机借了火， 但我不想在这个时刻再和任何陌生人言语， 所以我只能一支接着一支抽烟，那火光才不会断去。 自然的，我站在车外。几个小时后，香火终于断了，我俯身进车，捏了一把小家伙的脸说， 我找找烟。打开了汽车的扶手箱，我掏到了在最深处的一个小玩意，取出来发现那是一只录音笔，我搜寻记忆，才想起那是娜娜扔在这台车里的。它躺在这里面已经两年，我接下播放键，居然还有闪烁着的最后一格电，娜娜轻唱着摇篮曲，我不知道是不是空气越稀薄，声音便传越远，还是空气稀薄的地方一定没有人烟和喧闹，我总觉得这轻微的声音在山谷里来回飘荡，我将录音笔拿起来，放在小女孩耳边，说，你妈。她兴奋地乱抓，突然间，歌声戛然而止，传来三下轻促的敲击化妆台的声音， 然后是另外一个女声说道，娜娜，接客了。在娜娜回着哦的同时，这段录音结束了。我连忙抽回录音笔，观察着小家伙的表情，她似乎有所察觉，放下了小爪子疑惑地看着我。我将录音内容倒回到被中断前的最后一声歌声，然后按下录音键，摇下窗户，我想山谷里的风雨声可以洗掉那些对话，覆盖了十多秒以后，我把手从窗外抽了回来，刚要按下结束，小家伙突然对着录音笔喊了一声 “咦”，然后录音笔自己没电了。这是她第一次正儿八经说话， 我曾一度害怕她不能言语。这第一声，她既不喊爸爸，也未喊妈妈，只是对着这个世界抛下了一个疑问。 那只录音笔里的歌声寄托了娜娜对孩子的无限母爱，可以想象娜娜在唱歌的时候心里是怀着怎样的柔情蜜意和美好憧憬，可惜随即被现实硬生生地打断，提醒她还是一个妓女。陆子野从录音笔里抹掉了这一段，取而代之的是小家伙的第一句话语。可以想见，他将来不会告诉孩子她妈妈是做什么的。这已经是我想象到的最大的善意。本书里写过的几乎所有人都死了，只在结尾留下了一个纯洁的孩子。昨日之路布满荆棘，未来还有无限希望。这也是韩寒小说一直以来给读者最大的善意。 12、其实韩寒赋予1988这部小说的另一个意义就是纪念他那些死去的朋友。 在这部小说出版以前，韩寒的朋友里面去世的有王唯懿还有徐浪。这里特别要提到徐浪。从我看韩寒的博客开始（大概06年），徐浪这个名字就一直在他的博客里时不时出现，从他的描述中看得出，徐浪是一个乐观热情乐于助人的人，与韩寒的关系是亦师亦友，教会了韩寒很多赛车技巧。突然08年的一天，韩寒写了一篇《写给徐浪》，对赛车一窍不通的我才知道，一位中国拉力车王去世了。韩寒说过，徐浪的去世是影响他最大的事情，甚至改变了他一些。在之后的文章和访谈里，他也多次提到徐浪。]]></content>
      <categories>
        <category>小说</category>
        <category>韩寒</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>书摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQ培训总结]]></title>
    <url>%2F2017%2F09%2F06%2FMQ%E5%9F%B9%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、导论公司最近进行了MQ的培训，总结一下培训的内容。 二、MQ简介2.1、什么是消息队列MQ消息队列（Message queue）是在消息的传输过程中保存消息的容器。消息队列管理器在将消息从它的源中继到它的目标时充当中间人。队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它。 2.2、MQ通讯模式 点对点通讯 (p2p) 发布/订阅 (pub/sub) 2.3、常见的MQ队列 ActiveMQ RabbitMQ ZeroMQ Kafka RocketMQ NSQ 三、MQ 队列使用场景3.1、应用解耦场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图： 传统模式的缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合如何解决以上问题呢？引入应用消息队列后的方案，如下图： 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦 3.2、异步通信场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种。串行和并行 a、串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。 b、并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间 假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？ 引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下： 按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍。 3.3、流量削峰流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。 可以控制活动的人数。 可以缓解短时间内高流量压垮应用。 用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。秒杀业务根据消息队列中的请求信息，再做后续处理 四、阿里云4.1、阿里MQ简介 提供了TCP、HTTP、MQTT 三种协议层面的接入方式 支持 Java、C++ 以及 .NET 不同语言推荐大家直接看这个吧， 阿里云MQ文档链接： https://help.aliyun.com/product/29530.html?spm=5176.doc29533.3.1.zGwE4m 4.2、阿里MQ 消息类型4.2.1、定时消息Producer 将消息发送到 MQ 服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费，该消息即定时消息 123Message msg = new Message(…)long timeStamp = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).parse(&quot;2016-03-07 16:21:00&quot;).getTime();msg.setStartDeliverTime(timeStamp); 4.2.2、延时消息Producer 将消息发送到 MQ 服务端，但并不期望这条消息立马投递，而是延迟一定时间后才投递到 Consumer 进行消费，该消息即延时消息。 123Message msg = new Message(…);long delayTime = 3000;msg.setStartDeliverTime(System.currentTimeMillis() + delayTime); 4.2.3、顺序消息顺序消息是 MQ 提供的一种按照顺序进行发布和消费的消息类型。顺序消息由两个部分组成：顺序发布和顺序消费。 顺序发布：对于指定的一个 Topic，客户端将按照一定的先后顺序进行发送消息。 顺序消费：对于指定的一个 Topic，按照一定的先后顺序进行接收消息，即先发送的消息一定会先被客户端接收到。 顺序消息类型分为两种：全局顺序和分区顺序。 4.2.3、事物消息事务消息的 Producer ID 不能与其他类型消息的 Producer ID 共用。通过 ONSFactory.createTransactionProducer 创建事务消息的 Producer 时必须指定 LocalTransactionChecker 的实现类，处理异常情况下事务消息的回查。事务消息发送完成本地事务后，可在 execute 方法中返回如下三种状态： TransactionStatus.CommitTransaction 提交事务，允许订阅方消费该消息。 TransactionStatus.RollbackTransaction 回滚事务，消息将被丢弃不允许消费。 TransactionStatus.Unknow 暂时无法判断状态，期待固定时间以后 MQ Server 向发送方进行消息回查。 五、NSQ5.1、NSQ简介NSQ是一个基于Go语言的开源的分布式实时消息平台。NSQ可用于大规模系统的实时消息服务，它的设计目标是为在分布式环境下提供一个强大的去除中心化的分布式服务架构，可以每天处理数以亿计的实时消息。 5.2、NSQ四大组件 nsqlookupd：管理nsqd节点拓扑信息并提供最终一致性的发现服务的守护进程。 nsqd：负责接收、排队、转发消息到客户端的守护进程，并且定时向nsqlookupd服务发送心跳。 nsqadmin：nsq的web统计界面，可实时查看集群的统计数据和执行一些管理任务。 utilities：常见基础功能、数据流处理工具，如nsq_stat、nsq_tail、nsq_to_file、nsq_to_http、nsq_to_nsq、to_nsq。 5.3、主要功能 具有分布式且无单点故障的拓扑结构 支持水平扩展，在无中断情况下能够无缝地添加集群节点 低延迟的消息推送，参见官方提供的性能说明文档 具有组合式的负载均衡和多播形式的消息路由 既擅长处理面向流（高吞吐量）的工作负载，也擅长处理面向Job的（低吞吐量）工作负载 消息数据既可以存储于内存中，也可以存储在磁盘中 实现了生产者、消费者自动发现和消费者自动连接生产者，参见nsqlookupd 支持安全传输层协议（TLS），从而确保了消息传递的安全性 具有与数据格式无关的消息结构，支持JSON、Protocol Buffers、MsgPacek等消息格式 非常易于部署（几乎没有依赖）和配置（所有参数都可以通过命令行进行配置） 使用了简单的TCP协议且具有多种语言的客户端功能库 具有用于信息统计、管理员操作和实现生产者等的HTTP接口 为实时检测集成了统计数据收集器StatsD 具有强大的集群管理界面，参见nsqadmin 5.4、NSQ的安装 选择版本： nsq-1.0.0-compat.windows-amd64.go1.8.tar.gz。 运行 nsqlookupd (TCP 监听端口： 4160, HTTP 监听端口：4161)。 运行 nsqd –lookupd-tcp-address=127.0.0.1:4160 (TCP 监听端口：4150, HTTP监听端口：4151, 启动后会与 nsqlookupd 之间发送心跳)。 运行 nsqadmin –lookupd-http-address=127.0.0.1:4161 (HTTP监听端口：4171, 访问 http://ip:4171 可以看到监控UI)。 运行 curl -d ‘hello world 1’ ‘http://127.0.0.1:4151/pub?topic=test‘ , 创建一个topic：test 且向test中发送 “hello world 1”。 运行 nsq_to_file –topic=test –output-dir=F:/tmp –lookupd-http-address=127.0.0.1:4161 将消息落盘 继续发布更多的消息： curl -d ‘hello world 2’ ‘http://127.0.0.1:4151/pub?topic=test&#39;。 启动后的视图如下： 5.5、NSQ的架构 六、消息系统对比图]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程下的单例思考]]></title>
    <url>%2F2017%2F08%2F23%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[一、导论逛论坛看到一个耐人寻味的问题，单例模式在多线程下会产生什么有趣的问题，花了半个小时玩了玩，在此记录一下。 二、单线程下的单例模式单线程下的单例模式不用细说，随便跑，总是同一个实例，不会产生两个不同的实例，不想多解释了。 三、多线程模式下的单例模式12345678910111213141516171819202122232425262728293031323334353637383940414243package com.mxl.design.model.singleton;public class TestSingleton &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + Singleton.getInstance().hashCode()); &#125; &#125;); thread.setName(&quot;Thread&quot; + i); thread.start(); &#125; &#125; static class Singleton &#123; // 注意这里都是加上了volatile关键字的 private static volatile Singleton cache = null; private static Object mutexObj = new Object(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; Singleton tmp = cache; if (tmp == null) &#123; tmp = cache; synchronized (mutexObj) &#123; if (tmp == null) &#123; tmp = new Singleton(); cache = tmp; &#125; &#125; &#125; return tmp; &#125; &#125;&#125; 笔者在测试类TestSingleton中创建了内部类，并使用volatile关键字修饰了实例，多次运行发现问题不小。 第一次运行123Thread1 427340025Thread0 1446427658Thread2 427340025 第二次运行123Thread1 863719801Thread0 863719801Thread2 863719801 第三次运行123Thread1 863719801Thread0 863719801Thread2 863719801 可以发现问题所在，第一次并没有产生单例，后两次确实是产生了单例，这就是问题所在，问题出现在代码32行，后面解释。后来笔者在代码中加上了更详细的注释，继续看看。 四、更详细的单例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.mxl.design.model.singleton;public class TestSingletonForText &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + SingletonForText.getInstance().hashCode()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.setName(&quot;Thread&quot; + i); thread.start(); &#125; &#125; public static class SingletonForText &#123; // 注意这里都是加上了volatile关键字的 private static volatile SingletonForText cache = null; private static Object mutexObj = new Object(); private SingletonForText() &#123; &#125; public static SingletonForText getInstance() throws InterruptedException &#123; SingletonForText tmp = null; if (tmp == null) &#123; System.out.println(Thread.currentThread().getName() + &quot; : 开始第一个条件判断&quot;); synchronized (mutexObj) &#123; System.out.println(Thread.currentThread().getName() + &quot; : 进入同步块&quot;); tmp = cache; if (tmp == null) &#123; System.out.println(Thread.currentThread().getName() + &quot; : 开始第二个条件判断&quot;); tmp = new SingletonForText(); cache = tmp; System.out.println(Thread.currentThread().getName() + &quot; : 结束第二个条件判断&quot;); &#125; System.out.println(Thread.currentThread().getName() + &quot; : 结束同步块&quot;); &#125; System.out.println(Thread.currentThread().getName() + &quot; : 结束第一个条件判断&quot;); &#125; return tmp; &#125; &#125;&#125; 多次执行第一次执行12345678910111213141516171819Thread0 : 开始第一个条件判断Thread2 : 开始第一个条件判断Thread1 : 开始第一个条件判断Thread0 : 进入同步块Thread0 : 开始第二个条件判断Thread0 : 结束第二个条件判断Thread1 : 进入同步块Thread1 : 结束第二个条件判断Thread1 : 结束同步块Thread1 : 结束第一个条件判断Thread1 : 1113847530Thread0 : 结束同步块Thread0 : 结束第一个条件判断Thread0 : 1113847530Thread2 : 进入同步块Thread2 : 结束第二个条件判断Thread2 : 结束同步块Thread2 : 结束第一个条件判断Thread2 : 1113847530 第二次执行12345678910111213141516171819Thread2 : 开始第一个条件判断Thread2 : 进入同步块Thread2 : 开始第二个条件判断Thread1 : 开始第一个条件判断Thread0 : 开始第一个条件判断Thread2 : 结束第二个条件判断Thread0 : 进入同步块Thread0 : 结束第二个条件判断Thread2 : 结束同步块Thread1 : 进入同步块Thread0 : 结束同步块Thread1 : 结束第二个条件判断Thread2 : 结束第一个条件判断Thread1 : 结束同步块Thread1 : 结束第一个条件判断Thread1 : 820485811Thread0 : 结束第一个条件判断Thread0 : 820485811Thread2 : 820485811 第三次执行12345678910111213141516171819Thread2 : 开始第一个条件判断Thread1 : 开始第一个条件判断Thread0 : 开始第一个条件判断Thread2 : 进入同步块Thread2 : 开始第二个条件判断Thread2 : 结束第二个条件判断Thread2 : 结束同步块Thread0 : 进入同步块Thread2 : 结束第一个条件判断Thread0 : 结束第二个条件判断Thread0 : 结束同步块Thread1 : 进入同步块Thread1 : 结束第二个条件判断Thread1 : 结束同步块Thread1 : 结束第一个条件判断Thread1 : 1678885403Thread2 : 1678885403Thread0 : 结束第一个条件判断Thread0 : 1678885403 这样看好像又没有问题了，仔细检查代码发现synchronize之前赋值的代码都被并发访问了，所以后来cache赋给tmp是起不到作用的，不管cache是否为null,但是同步代码块中tmp = cache;这一步是在同步代码块中，多个线程是不能并发访问的，致使下面的判断tmp是否为null都是符合逻辑的，产生的都是同一个实例，这也是最后抢到资源的线程没有执行第二个条件判断的原因。 五、总结又沿着这条思路发现了单例模式下的不少有意思的东西，比如多线程下采用静态内部类编写单例，或者采用volatile修饰单例懒汉模式下的单例对象等等，后续再记录。]]></content>
      <categories>
        <category>问题思考</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>jdk</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于maven引用依赖报错]]></title>
    <url>%2F2017%2F08%2F21%2F%E5%85%B3%E4%BA%8Emaven%E5%BC%95%E7%94%A8%E4%BE%9D%E8%B5%96%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[一、导论今天遇到一个比较坑的问题，后来才发现是自己犯傻了，记录一下，避免以后重复犯错。 二、问题详情异常代码1The type com.snowball.tsm.datagram.Command cannot be resolved. It is indirectly referenced from required .class files 三、问题原因1List&lt;com.snowball.tsm.datagram.Command&gt; commands = shiftInResponse.getCommands(); 问题就出现在这里，这里引用了两个相同名称的类Command，但是包路径不一样，导致引用失败，检查了半天发现pom文件里面的jar的该有的都有，不应该啊。后来才发现其中一个Command是在tsm中，然而我并没有发现，一直在hub中再找，路径都不对哥你当然找不到啦。 四、解决办法在maven配置文件中加上tsm依赖，问题解决12345&lt;dependency&gt; &lt;groupId&gt;com.snowball.tsm&lt;/groupId&gt; &lt;artifactId&gt;tsm-protocol&lt;/artifactId&gt; &lt;version&gt;1.0.4&lt;/version&gt;&lt;/dependency&gt; 五、反省检查代码不够细心，时间浪费在弱智问题上。]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Builder创建对象]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%BD%BF%E7%94%A8Builder%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[导论昨天又刷了一遍《Effective java》创建对象相关的内容，感觉还是有必要记录归档下，方便记忆和以后复习。 对于一个有着大量可选参数的类来说，我们在构建的时候一般有一下几种方式： 方式一：静态工厂方法静态工厂方法相比于普通的构造器有如下优点： 静态工厂方法有名称，便于阅读。 调用静态工厂方法无需创建对象。 静态工厂方法可以返回返回类型的任何子类 在创建参数化实例对象时，代码会变得更加的简介 直接看enumSet中的源代码就可以了，典型的静态工厂方法12345678910public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123; Enum[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + &quot; not an enum&quot;); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe);&#125; 方式二：JavaBean模式核心代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class User &#123; private long uid; private String nick; private int gender; private int age; private String email; public long getUid() &#123; return uid; &#125; public void setUid(long uid) &#123; this.uid = uid; &#125; public String getNick() &#123; return nick; &#125; public void setNick(String nick) &#123; this.nick = nick; &#125; public int getGender() &#123; return gender; &#125; public void setGender(int gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; 客户端代码123456User user = new User();user.setAge(23);user.setGender(1);user.setNick(&quot;superman&quot;);user.setEmail(&quot;abc@xx.com&quot;);user.setUid(10001); 这种模式应该是平时用的最多的，但是遇到大量参数的对象时候这种模式就会让代码显得很冗余。 方式三：Builder构建模式这种模式解决了上面的大量参数，设置参数线程不安全的问题，由于Builder采用的是内部类，所以不存在线程安全的问题。代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.mxl.builder.model;/** * * @author Mao * */public class NutritionFacts &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder &#123; private final int servingSize; private final int servings; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val) &#123; this.calories = val; return this; &#125; public Builder fat(int val) &#123; this.fat = val; return this; &#125; public Builder sodium(int val) &#123; this.sodium = val; return this; &#125; public Builder carbohydrate(int val) &#123; this.carbohydrate = val; return this; &#125; public NutritionFacts build() &#123; return new NutritionFacts(this); &#125; &#125; //私有构造方法将builder参数copy到NutritionFacts中 private NutritionFacts(Builder build) &#123; servingSize = build.servingSize; servings = build.servings; sodium = build.sodium; fat = build.fat; calories = build.calories; carbohydrate = build.carbohydrate; &#125; @Override public String toString() &#123; return &quot;NutritionFacts [servingSize=&quot; + servingSize + &quot;, servings=&quot; + servings + &quot;, calories=&quot; + calories + &quot;, fat=&quot; + fat + &quot;, sodium=&quot; + sodium + &quot;, carbohydrate=&quot; + carbohydrate + &quot;]&quot;; &#125; //客户端创建对象 public static void main(String[] args) &#123; NutritionFacts demo = new NutritionFacts.Builder(10, 20).calories(15) .fat(24).carbohydrate(23).carbohydrate(27).build(); System.out.println(demo); &#125;&#125; 代码很简洁，容易阅读。但是它自身也还是有一些缺陷的，在创建一个对象的时候必须先构建一个他的Builder对象，还是增加了一些开销。]]></content>
      <categories>
        <category>jdk笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>对象创建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解内部类]]></title>
    <url>%2F2017%2F08%2F08%2F%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一、导论昨天看完了《java编程思想》中内部类部分，颇有感悟，想写一篇总结，但是工作的原因，一直没时间写，直接搬来网上不错的软文。 内部类可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一个非常有用的特性但又比较难理解使用的特性。 通俗讲：内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。 先看看最基本的内部类，自己先体会 123456789101112131415161718192021222324252627public class OuterClass &#123; private String name ; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; class InnerClass&#123; public InnerClass()&#123; name = &quot;chenssy&quot;; age = 23; &#125; &#125;&#125; 二、为什么要使用内部类为什么要使用内部类？ 在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。 123456789101112131415161718public interface Father &#123;&#125;public interface Mother &#123;&#125;public class Son implements Father, Mother &#123;&#125;public class Daughter implements Father&#123; class Mother_ implements Mother&#123; &#125;&#125; 其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。 其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。3、创建内部类对象的时刻并不依赖于外围类对象的创建。4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。 三、内部类基础在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 1234567891011121314151617181920212223242526public class OuterClass &#123; private String name ; private int age; /**省略getter和setter方法**/ public class InnerClass&#123; public InnerClass()&#123; name = &quot;chenssy&quot;; age = 23; &#125; public void display()&#123; System.out.println(&quot;name：&quot; + getName() +&quot; ;age：&quot; + getAge()); &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.display(); &#125;&#125;--------------Output：name：chenssy ;age：23 在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。 其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类： **OuterClass.InnerClass innerClass = outerClass.new InnerClass();. 同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。 1234567891011121314151617181920public class OuterClass &#123; public void display()&#123; System.out.println(&quot;OuterClass...&quot;); &#125; public class InnerClass&#123; public OuterClass getOuterClass()&#123; return OuterClass.this; &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.getOuterClass().display(); &#125;&#125;-------------Output:OuterClass... 到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。 在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。 四、成员内部类成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。 在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 12345678910111213141516171819202122232425262728293031public class OuterClass &#123; private String str; public void outerDisplay()&#123; System.out.println(&quot;outerClass...&quot;); &#125; public class InnerClass&#123; public void innerDisplay()&#123; //使用外围内的属性 str = &quot;chenssy...&quot;; System.out.println(str); //使用外围内的方法 outerDisplay(); &#125; &#125; /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */ public InnerClass getInnerClass()&#123; return new InnerClass(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.getInnerClass(); inner.innerDisplay(); &#125;&#125;--------------------chenssy...outerClass... 推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。 五、局部内部类有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。 定义在方法里： 12345678910111213141516171819public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation(&quot;chenssy&quot;); &#125;&#125; 定义在作用域内: 1234567891011121314151617181920212223242526public class Parcel6 &#123; private void internalTracking(boolean b)&#123; if(b)&#123; class TrackingSlip&#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip()&#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip(&quot;chenssy&quot;); String string = ts.getSlip(); &#125; &#125; public void track()&#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel6 parcel6 = new Parcel6(); parcel6.track(); &#125;&#125; 六、匿名内部类在做Swing编程中，我们经常使用这种方式来绑定事件 123456button2.addActionListener( new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;你按了按钮二&quot;); &#125; &#125;); 我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子： 1234567891011121314151617181920212223public class OuterClass &#123; public InnerClass getInnerClass(final int num,String str2)&#123; return new InnerClass()&#123; int number = num + 3; public int getNumber()&#123; return number; &#125; &#125;; /* 注意：分号不能省 */ &#125; public static void main(String[] args) &#123; OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, &quot;chenssy&quot;); System.out.println(inner.getNumber()); &#125;&#125;interface InnerClass &#123; int getNumber();&#125;----------------Output: 这里我们就需要看清几个地方 1、 匿名内部类是没有访问修饰符的。 2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。 3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final 4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。 七、静态内部类关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 1、 它的创建是不需要依赖于外围类的。 2、 它不能使用任何外围类的非static成员变量和方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class OuterClass &#123; private String sex; public static String name = &quot;chenssy&quot;; /** *静态内部类 */ static class InnerClass1&#123; /* 在静态内部类中可以存在静态成员 */ public static String _name1 = &quot;chenssy_static&quot;; public void display()&#123; /* * 静态内部类只能访问外围类的静态成员变量和方法 * 不能访问外围类的非静态成员变量和方法 */ System.out.println(&quot;OutClass name :&quot; + name); &#125; &#125; /** * 非静态内部类 */ class InnerClass2&#123; /* 非静态内部类中不能存在静态成员 */ public String _name2 = &quot;chenssy_inner&quot;; /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */ public void display()&#123; System.out.println(&quot;OuterClass name：&quot; + name); &#125; &#125; /** * @desc 外围类方法 * @author chenssy * @data 2013-10-25 * @return void */ public void display()&#123; /* 外围类访问静态内部类：内部类. */ System.out.println(InnerClass1._name1); /* 静态内部类 可以直接创建实例不需要依赖于外围类 */ new InnerClass1().display(); /* 非静态内部的创建需要依赖于外围类 */ OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2(); /* 方位非静态内部类的成员需要使用非静态内部类的实例 */ System.out.println(inner2._name2); inner2.display(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); outer.display(); &#125;&#125;----------------Output:chenssy_staticOutClass name :chenssychenssy_innerOuterClass name：chenssy 上面这个例子充分展现了静态内部类和非静态内部类的区别。]]></content>
      <categories>
        <category>jdk笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git指令笔记归总]]></title>
    <url>%2F2017%2F08%2F04%2Fgit%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、导论紧随上一篇maven指令，同样是指令的总结，git是目前最好用的项目组管理工具，笔者也是一直在用。上一篇maven指令是干货搬运，我想说的是这篇也是一样的，因为实在是没有什么可写的，笔记总结无非就是记录这些玩意。实实在在的干货，不解释。 二、常用指令git init 在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone 获取一个url对应的远程Git repo, 创建一个local copy. 一般的格式是git clone [url].clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git status 查询repo的状态. git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git log show commit history of a branch. git log --oneline --number: 每条log只显示一行,显示number条. git log --oneline --graph:可以图形化地表示出分支合并历史. git log branchname可以显示特定分支的log. git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号). git log --decorate会显示出tag信息. git log --author=[author name] 可以指定作者的提交历史. git log --since --before --until --after 根据提交时间筛选log. --no-merges可以将merge的commits排除在外. git log --grep 根据commit信息过滤log: git log --grep=keywords 默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option. git log -S: filter by introduced diff. 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). git log -p: show patch introduced at each commit. 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. 另一种方法是git show [SHA]. git log --stat: show diffstat of changes introduced at each commit. 同样是用来看改动的相对信息的,--stat比-p的输出更简单一些. git add 在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. git add . 会递归地添加当前工作目录中的所有文件. git diff 不加参数的git diff: show diff of unstaged changes. 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用: git diff --cached 命令. show diff of staged changes. (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的). git diff HEAD show diff of all staged or unstated changes. 也即比较woking directory和上次提交之间所有的改动. 如果想看自从某个版本之后都改动了什么,可以用: git diff [version tag] 跟log命令一样,diff也可以加上--stat参数来简化输出. git diff [branchA] [branchB]可以用来比较两个分支. 它实际上会返回一个由A到B的patch,不是我们想要的结果. 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令: git diff [branchA]…[branchB]给出的. 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit 提交已经被add进来的改动. git commit -m “the commit message&quot; git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git reset undo changes and commits. 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. git reset HEAD: unstage files from index and reset pointer to HEAD 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加. git reset --soft move HEAD to specific commit reference, index and staging are untouched. git reset --hard unstage files AND undo any changes in the working directory since last commit. 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. 这里的HEAD可以被写成任何一次提交的SHA-1. 不带soft和hard参数的git reset,实际上带的是默认参数mixed. 总结: git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容. git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容. git reset --hard id.是将git的HEAD变了,文件也变了. 按改动范围排序如下: soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert 反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. git revert HEAD: 撤销最近的一个提交. git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rm git rm file: 从staging区移除文件,同时也移除出工作目录. git rm --cached: 从staging区移除文件,但留在工作目录中. git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git clean git clean是从工作目录中移除没有track的文件. 通常的参数是git clean -df: -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git stash 把当前的改动压入一个栈. git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. git stash list会显示这个栈的list. git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录. 也可以指定别的项目,比如git stash apply stash@{1}. 如果你在应用stash中项目的同时想要删除它,可以用git stash pop 删除stash中的项目: git stash drop: 删除上一个,也可指定参数删除指定的一个项目. git stash clear: 删除所有项目. git branch git branch可以用来列出分支,创建分支和删除分支. git branch -v可以看见每一个分支的最后一次提交. git branch: 列出本地所有分支,当前分支会被星号标示出. git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支. 删除remote的分支: git push (remote-name) :(branch-name): delete a remote branch. 这个是因为完整的命令形式是: git push remote-name local-branch:remote-branch 而这里local-branch的部分为空,就意味着删除了remote-branch git checkout git checkout (branchname) 切换到一个分支. git checkout -b (branchname): 创建并切换到新的分支. 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. checkout还有另一个作用:替换本地改动: git checkout --&lt;filename&gt; 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge 把一个分支merge进当前的分支. git merge [alias]/[branch] 把远程分支merge到当前分支. 如果出现冲突,需要手动修改,可以用git mergetool. 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tag tag a point in history as import. 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. 比如: git tag v1.0 git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. 我们可以利用commit SHA来给一个过去的提交打tag: git tag -a v0.9 XXXX push的时候是不包含tag的,如果想包含,可以在push时加上--tags参数. fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项. git remote list, add and delete remote repository aliases. 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. git remote: 列出remote aliases. 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. git remote -v:可以看见每一个别名对应的实际url. git remote add [alias] [url]: 添加一个新的remote repo. git remote rm [alias]: 删除一个存在的remote alias. git remote rename [old-alias] [new-alias]: 重命名. git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. git fetch download new branches and data from a remote repository. 可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repo fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pull fetch from a remote repo and try to merge into the current branch. pull == fetch + merge FETCH_HEAD git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用--rebase参数,它会执行git rebase来取代原来的git merge. git rebase --rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: git rebase --continue就会继续打余下的补丁. git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态. git push push your new branches and data to a remote repository. git push [alias] [branch]将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip, 说明地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git reflog git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. 当git reflog不指定引用的时候,默认列出HEAD的reflog. HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值. git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中. 特殊符号: ^代表父提交,当一个提交有多个父提交时,可以通过在^后面跟上一个数字,表示第几个父提交: ^相当于^1. ~&lt;n&gt;相当于连续的&lt;n&gt;个^.]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven常用指令笔记]]></title>
    <url>%2F2017%2F08%2F04%2F%E8%AE%B0%E5%BD%95maven%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、导论论坛上看到有总结maven指令的，之前一直想整理一下maven的常用指令，因为确实平时用的非常多，由于个人拖延症原因一直没有记录，看到有人总结的这么好还是直接搬过来吧，省事。。。。 二、Maven常用命令： 创建Maven的普通java项目：mvn archetype:create-DgroupId=packageName-DartifactId=projectName 创建Maven的Web项目： mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp 编译源代码： mvn compile 编译测试代码：mvn test-compile 运行测试：mvn test 产生site：mvn site 打包：mvn package 在本地Repository中安装jar：mvn install 清除产生的项目：mvn clean 生成eclipse项目：mvn eclipse:eclipse 生成idea项目：mvn idea:idea 组合使用goal命令，如只打包不测试：mvn -Dtest package 编译测试的内容：mvn test-compile 只打jar包: mvn jar:jar 只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile ( -skipping 的灵活运用，当然也可以用于其他组合命令) 清除eclipse的一些系统设置:mvn eclipse:clean ps： 一般使用情况是这样，首先通过cvs或svn下载代码到本机，然后执行mvn eclipse:eclipse生成ecllipse项目文件，然后导入到eclipse就行了；修改代码后执行mvn compile或mvn test检验，也可以下载eclipse的maven插件。 mvn -version/-v 显示版本信息mvn archetype:generate 创建mvn项目mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app 创建mvn项目 mvn package 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件mvn jetty:run 运行项目于jetty上,mvn compile 编译mvn test 编译并测试mvn clean 清空生成的文件mvn site 生成项目相关信息的网站mvn -Dwtpversion=1.0 eclipse:eclipse 生成Wtp插件的Web项目mvn -Dwtpversion=1.0 eclipse:clean 清除Eclipse项目的配置信息(Web项目)mvn eclipse:eclipse 将项目转化为Eclipse项目 在应用程序用使用多个存储库123456789101112&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;Ibiblio&lt;/id&gt; &lt;name&gt;Ibiblio&lt;/name&gt; &lt;url&gt;http://www.ibiblio.org/maven/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;PlanetMirror&lt;/id&gt; &lt;name&gt;Planet Mirror&lt;/name&gt; &lt;url&gt;http://public.planetmirror.com/pub/maven/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; mvn deploy 将项目打成jar发到私服1mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:\client-0.1.0.jar -DrepositoryId=maven-repository-inner -Durl=ftp://xxxxxxx/opt/maven/repository/ 发布第三方Jar到本地库中： mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:\client-0.1.0.jar -DdownloadSources=true -DdownloadJavadocs=true mvn -e 显示详细错误 信息.mvn validate 验证工程是否正确，所有需要的资源是否可用。mvn test-compile 编译项目测试代码。 。mvn integration-test 在集成测试可以运行的环境中处理和发布包。mvn verify 运行任何检查，验证包是否有效且达到质量标准。mvn generate-sources 产生应用需要的任何额外的源代码，如xdoclet。 三、常用命令：mvn -v 显示版本mvn help:describe -Dplugin=help 使用 help 插件的describe 目标来输出 Maven Help 插件的信息。 mvn help:describe -Dplugin=help -Dfull 使用Help 插件输出完整的带有参数的目标列 mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull 获取单个目标的信息,设置 mojo 参数和 plugin 参数。此命令列出了Compiler 插件的compile 目标的所有信息 mvn help:describe -Dplugin=exec -Dfull 列出所有 Maven Exec 插件可用的目标 mvn help:effective-pom 看这个“有效的 (effective)”POM，它暴露了 Maven的默认设置 mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 -DartifactId=simple -DpackageName=org.sonatype.mavenbook 创建Maven的普通java项目，在命令行使用Maven Archetype 插件 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序mvn dependency:resolve 打印出已解决依赖的列表mvn dependency:tree 打印整个依赖树 mvn install -X 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行 mvn install -Dmaven.test.skip=true 给任何目标添加maven.test.skip 属性就能跳过测试 mvn install assembly:assembly 构建装配Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件 mvn jetty:run 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 mvn compile 编译你的项目 mvn clean install 删除再编译 mvn hibernate3:hbm2ddl 使用 Hibernate3 插件构造数据库]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具类之spring beanUtils和apache beanUtils]]></title>
    <url>%2F2017%2F08%2F02%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8Bspring%20beanUtils%E5%92%8Capache%20beanUtils%2F</url>
    <content type="text"><![CDATA[一、beanUtils开发过程中会遇到对象之间的属性copy，避免了使用get/set重复操作，BeanUtils还是挺好用的。在开发过程中，使用BeanUtils确实会节省很多代码，让代码清晰简洁，但是性能却不一定会高过get/set，这里不考虑性能，就从便利性方面记录一下最近用过的工具类，再比较一下两种工具类的区别。BeanUtils中有很多好用的方法，用起来确实是很爽，但是所有的东西有利必有弊，怎样用好这些工具类大杀器，还是得看实际业务。下面以copyProperties(sourceDate, targetData)方法为例记录使用过程。 二、实例源数据对象12345678910111213141516171819202122232425262728293031323334353637383940414243package com.mxl.utils;import java.util.Date;public class SourceData &#123; private String name; private String email; private Date createDate; public SourceData()&#123;&#125;; public SourceData(String name , String email , Date createDate) &#123; this.name = name; this.email = email; this.createDate = createDate; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getCreateDate() &#123; return createDate; &#125; public void setCreateDate(Date createDate) &#123; this.createDate = createDate; &#125; @Override public String toString() &#123; return &quot;SourceData [name=&quot; + name + &quot;, email=&quot; + email + &quot;, createDate=&quot; + createDate + &quot;]&quot;; &#125;&#125; 目标数据对象1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.mxl.utils;import java.util.Date;public class TargetData &#123; private String name; private String email; private Date createDate; public TargetData()&#123;&#125;; public TargetData(String name , String email , Date createDate) &#123; this.name = name; this.email = email; this.createDate = createDate; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getCreateDate() &#123; return createDate; &#125; public void setCreateDate(Date createDate) &#123; this.createDate = createDate; &#125; @Override public String toString() &#123; return &quot;TargetData [name=&quot; + name + &quot;, email=&quot; + email + &quot;, createDate=&quot; + createDate + &quot;]&quot;; &#125; &#125; 客户端代码 12345678910111213141516171819202122232425package com.mxl.utils;import java.lang.reflect.InvocationTargetException;import java.util.Date;public class TestBeanUtils &#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException &#123; SourceData sourceDate = new SourceData(&quot;曹操&quot; , &quot;caocao@163.com&quot; , new Date(0)); TargetData targetData = new TargetData(); //spring中的BeanUtils org.springframework.beans.BeanUtils.copyProperties(sourceDate, targetData); System.out.println(&quot;spring BeanUtils : &quot; + targetData.toString()); //apache中的BeanUtils org.apache.commons.beanutils.BeanUtils.copyProperties(targetData, sourceDate); System.out.println(&quot;apache BeanUtils : &quot; + targetData.toString()); &#125; &#125; 输出12spring BeanUtils : TargetData [name=曹操, email=caocao@163.com, createDate=Thu Jan 01 08:00:00 CST 1970]apache BeanUtils : TargetData [name=曹操, email=caocao@163.com, createDate=Thu Jan 01 08:00:00 CST 1970] 两个工具类都能将源数据copy到目标对象，但是这些工具都不是万能的，往下看。 源数据对象将createDate改为字符串类型，目标数据对象不变。1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.mxl.utils;import java.util.Date;public class SourceData &#123; private String name; private String email;// private Date createDate; private String createDate; public SourceData()&#123;&#125;; public SourceData(String name , String email , String createDate) &#123; this.name = name; this.email = email; this.createDate = createDate; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getCreateDate() &#123; return createDate; &#125; public void setCreateDate(String createDate) &#123; this.createDate = createDate; &#125; @Override public String toString() &#123; return &quot;SourceData [name=&quot; + name + &quot;, email=&quot; + email + &quot;, createDate=&quot; + createDate + &quot;]&quot;; &#125;&#125; 客户端代码 12345678910111213141516171819202122232425package com.mxl.utils;import java.lang.reflect.InvocationTargetException;import java.util.Date;public class TestBeanUtils &#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException &#123; SourceData sourceDate = new SourceData(&quot;曹操&quot; , &quot;caocao@163.com&quot; , new Date(0).toString()); TargetData targetData = new TargetData(); //spring中的BeanUtils// org.springframework.beans.BeanUtils.copyProperties(sourceDate, targetData);// // System.out.println(&quot;spring BeanUtils : &quot; + targetData.toString()); //apache中的BeanUtils org.apache.commons.beanutils.BeanUtils.copyProperties(targetData, sourceDate); System.out.println(&quot;apache BeanUtils : &quot; + targetData.toString()); &#125; &#125; 将spring的BeanUtils注释掉，先看Apache的BeanUtils能否正常工作，看输出。12345678910111213142017-8-2 15:32:29 org.apache.commons.beanutils.converters.DateConverter toDate警告: DateConverter does not support default String to &apos;Date&apos; conversion.2017-8-2 15:32:29 org.apache.commons.beanutils.converters.DateConverter toDate警告: (N.B. Re-configure Converter or use alternative implementation)Exception in thread &quot;main&quot; org.apache.commons.beanutils.ConversionException: DateConverter does not support default String to &apos;Date&apos; conversion. at org.apache.commons.beanutils.converters.DateTimeConverter.toDate(DateTimeConverter.java:468) at org.apache.commons.beanutils.converters.DateTimeConverter.convertToType(DateTimeConverter.java:343) at org.apache.commons.beanutils.converters.AbstractConverter.convert(AbstractConverter.java:156) at org.apache.commons.beanutils.converters.ConverterFacade.convert(ConverterFacade.java:60) at org.apache.commons.beanutils.BeanUtilsBean.convert(BeanUtilsBean.java:1078) at org.apache.commons.beanutils.BeanUtilsBean.copyProperty(BeanUtilsBean.java:437) at org.apache.commons.beanutils.BeanUtilsBean.copyProperties(BeanUtilsBean.java:286) at org.apache.commons.beanutils.BeanUtils.copyProperties(BeanUtils.java:137) at com.mxl.utils.TestBeanUtils.main(TestBeanUtils.java:20) 报错了，需要自定义转换器，现在没时间去自定义这个转化器，类似于struct2中的自定义转换器，定义好了之后肯定是能用的，就不细说了。再将spring的工具类注释放开，将Apache的工具类注释掉，看能否正常执行。 12345678910111213141516171819202122232425package com.mxl.utils;import java.lang.reflect.InvocationTargetException;import java.util.Date;public class TestBeanUtils &#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException &#123; SourceData sourceDate = new SourceData(&quot;曹操&quot; , &quot;caocao@163.com&quot; , new Date(0).toString()); TargetData targetData = new TargetData(); //spring中的BeanUtils org.springframework.beans.BeanUtils.copyProperties(sourceDate, targetData); System.out.println(&quot;spring BeanUtils : &quot; + targetData.toString()); //apache中的BeanUtils// org.apache.commons.beanutils.BeanUtils.copyProperties(targetData, sourceDate);// // System.out.println(&quot;apache BeanUtils : &quot; + targetData.toString()); &#125; &#125; 看输出。 1234567891011Exception in thread &quot;main&quot; org.springframework.beans.FatalBeanException: Could not copy properties from source to target; nested exception is java.lang.IllegalArgumentException: argument type mismatch at org.springframework.beans.BeanUtils.copyProperties(BeanUtils.java:621) at org.springframework.beans.BeanUtils.copyProperties(BeanUtils.java:531) at com.mxl.utils.TestBeanUtils.main(TestBeanUtils.java:15)Caused by: java.lang.IllegalArgumentException: argument type mismatch at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.springframework.beans.BeanUtils.copyProperties(BeanUtils.java:618) ... 2 more springframework的BeanUtils完全就不支持String转Date类型，比起Apache的BeanUtils还是有稍显逊色，网络上说法很多，各不一致，无赖花二十分钟亲自试了下，总结一下： 三、总结Apache的BeanUtils能支持大部分的类型属性copy，包括字符串转日期类型等等，但是需要自定义转换器，而springframework完全就不支持跨类型的转换，也没有自定义转换器这么一说。其次与网络上结果不一致的原因也可能是工具类版本不一样，笔者使用的spring版本是3.2.2，common版本是1.8.3。]]></content>
      <categories>
        <category>jdk</category>
        <category>spring</category>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次Enumeration的使用]]></title>
    <url>%2F2017%2F07%2F31%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Enumeration%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、Enumeration接口Enumeration接口本身不是一个数据结构。但是，对其他数据结构非常重要。 Enumeration接口定义了从一个数据结构得到连续数据的手段。例如，Enumeration定义了一个名为nextElement的方法，可以用来从含有多个元素的数据结构中得到的下一个元素。先看看Enumeration中的源码12345678910111213141516171819public interface Enumeration&lt;E&gt; &#123; /** * Tests if this enumeration contains more elements. * * @return &lt;code&gt;true&lt;/code&gt; if and only if this enumeration object * contains at least one more element to provide; * &lt;code&gt;false&lt;/code&gt; otherwise. */ boolean hasMoreElements(); /** * Returns the next element of this enumeration if this enumeration * object has at least one more element to provide. * * @return the next element of this enumeration. * @exception NoSuchElementException if no more elements exist. */ E nextElement();&#125; 它里面只声明了两个方法，用来遍历数据 二、实际使用先看看简单的测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.mxl.enumtest;import java.util.Enumeration;public class EnumTest &#123; class MyData &#123; public String[] data; // 构造器 MyData() &#123; data = new String[4]; data[0] = &quot;zero&quot;; data[1] = &quot;one&quot;; data[2] = &quot;two&quot;; data[3] = &quot;three&quot;; &#125; // 返回一个enumeration对象给使用程序 Enumeration getEnum() &#123; return new MyEnumeration(0, data.length, data); &#125; &#125; class MyEnumeration implements Enumeration &#123; int count; // 计数器 int length; // 存储的数组的长度 Object[] dataArray; // 存储数据数组的引用 // 构造器 public MyEnumeration(int count, int length, Object[] dataArray) &#123; this.count = count; this.length = length; this.dataArray = dataArray; &#125; public boolean hasMoreElements() &#123; return (count &lt; length); &#125; public Object nextElement() &#123; return dataArray[count++]; &#125; &#125; public static void main(String[] args) &#123; EnumTest enumTest = new EnumTest(); //内部类的实例化 Enumeration enumeration = enumTest.new MyData().getEnum(); //Enumeration的遍历 while (enumeration.hasMoreElements()) &#123; String s = (String) enumeration.nextElement(); System.out.println(s); &#125; &#125;&#125; 启动之后客户端输入如下1234zeroonetwothree 注意这里使用的事内部类，内部类的实例化有很多种方式，不一定非要这用这一种 三、枚举的各种使用实例直接上代码，看注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173package com.mxl.enumtest;/** * 枚举用法详解 * * @author Mao * */public class TestEnum &#123; /** * 普通枚举 * * @author Mao * */ public enum ColorEnum &#123; red, green, yellow, blue; &#125; /** * 枚举像普通的类一样可以添加属性和方法，可以为它添加静态和非静态的属性或方法 * * @author Mao * */ public enum SeasonEnum &#123; // 注：枚举写在最前面，否则编译出错 spring, summer, autumn, winter; private final static String position = &quot;test&quot;; public static SeasonEnum getSeason() &#123; if (&quot;test&quot;.equals(position)) return spring; else return winter; &#125; &#125; /** * 性别 * * 实现带有构造器的枚举 * * @author Mao * */ public enum Gender &#123; // 通过括号赋值,而且必须带有一个参构造器和一个属性跟方法，否则编译出错 // 赋值必须都赋值或都不赋值，不能一部分赋值一部分不赋值；如果不赋值则不能写构造器，赋值编译也出错 MAN(&quot;MAN&quot;), WOMEN(&quot;WOMEN&quot;); private final String value; // 构造器默认也只能是private, 从而保证构造函数只能在内部使用 Gender(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; &#125; /** * 订单状态 * * 实现带有抽象方法的枚举 * * @author Mao * */ public enum OrderState &#123; /** 已取消 */ CANCEL &#123; public String getName() &#123; return &quot;已取消&quot;; &#125; &#125;, /** 待审核 */ WAITCONFIRM &#123; public String getName() &#123; return &quot;待审核&quot;; &#125; &#125;, /** 等待付款 */ WAITPAYMENT &#123; public String getName() &#123; return &quot;等待付款&quot;; &#125; &#125;, /** 正在配货 */ ADMEASUREPRODUCT &#123; public String getName() &#123; return &quot;正在配货&quot;; &#125; &#125;, /** 等待发货 */ WAITDELIVER &#123; public String getName() &#123; return &quot;等待发货&quot;; &#125; &#125;, /** 已发货 */ DELIVERED &#123; public String getName() &#123; return &quot;已发货&quot;; &#125; &#125;, /** 已收货 */ RECEIVED &#123; public String getName() &#123; return &quot;已收货&quot;; &#125; &#125;; public abstract String getName(); &#125; public static void main(String[] args) &#123; // 枚举是一种类型，用于定义变量，以限制变量的赋值；赋值时通过“枚举名.值”取得枚举中的值 ColorEnum colorEnum = ColorEnum.blue; switch (colorEnum) &#123; case red: System.out.println(&quot;color is red&quot;); break; case green: System.out.println(&quot;color is green&quot;); break; case yellow: System.out.println(&quot;color is yellow&quot;); break; case blue: System.out.println(&quot;color is blue&quot;); break; &#125; // 遍历枚举 System.out.println(&quot;遍历ColorEnum枚举中的值&quot;); for (ColorEnum color : ColorEnum.values()) &#123; System.out.println(color); &#125; // 获取枚举的个数 System.out.println(&quot;ColorEnum枚举中的值有&quot; + ColorEnum.values().length + &quot;个&quot;); // 获取枚举的索引位置，默认从0开始 System.out.println(ColorEnum.red.ordinal());// 0 System.out.println(ColorEnum.green.ordinal());// 1 System.out.println(ColorEnum.yellow.ordinal());// 2 System.out.println(ColorEnum.blue.ordinal());// 3 // 枚举默认实现了java.lang.Comparable接口 System.out.println(ColorEnum.red.compareTo(ColorEnum.green));// -1 // -------------------------- System.out.println(&quot;===========&quot;); System.out.println(&quot;季节为&quot; + SeasonEnum.getSeason()); // -------------- System.out.println(&quot;===========&quot;); for (Gender gender : Gender.values()) &#123; System.out.println(gender.value); &#125; // -------------- System.out.println(&quot;===========&quot;); for (OrderState order : OrderState.values()) &#123; System.out.println(order.getName()); &#125; &#125;&#125; 看输出 12345678910111213141516171819202122232425color is blue遍历ColorEnum枚举中的值redgreenyellowblueColorEnum枚举中的值有4个0123-1===========季节为spring===========MANWOMEN===========已取消待审核等待付款正在配货等待发货已发货已收货 四、总结Enumeration是在看公司代码的过程中遇到的，由于之前没有使用过，所以去了解了下，jdk自带的一种数据结构。在jdk1.5以前，通常的做法是定义一个静态常量类，但自jdk1.5后，java引入了枚举（关键字enum，全称为 enumeration，值类型），在枚举中，我们可以把相关的常量分组到一个枚举类型里，枚举也比常量类有更多灵活的用法，使用枚举，可以有效的提高代码的整洁性、可读性、可维护性等等，这里简单总结一下常用的枚举用法。]]></content>
      <categories>
        <category>jdk</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM ClassLoad]]></title>
    <url>%2F2017%2F07%2F28%2FJvm%20classLoad%2F</url>
    <content type="text"><![CDATA[一、概述 首先先来看几个问题 jvm是如何加载这些Class文件的？jvm加载一个Class文件需要哪些步骤？Class文件中的信息进入到虚拟机后会发生什么变化？ 接下来看看jvm加载class文件的概述： jvm把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。这句话差不多已经回答上面三个问题的大部分了。 与那些在编译是需要进行连接工作的语言不同，在Java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载是稍微增加一些性能开销，但是却能为Java应用程序提供高度的灵活性，Java中可以动态的扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。比如编写一个使用接口的应用程序，可以等到运行时在指定其实际的实现。这种组装应用程序的方式广泛应用于Java程序之中。 二、要点 类从被加载到jvm内存中开始，到卸载出内存为止，它的生命周期包括了一下步骤：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Useing）和卸载（Unloading）七个阶段。其中的验证、准备和解析三个部分统称为链接（Linking），这七个阶段的发生顺序如下图，注意是发生的顺序，不是执行完成的先后顺序。 1、加载 加载阶段是“类加载”过程的一个阶段，虚拟机需要做以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的入口。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自定义，虚拟机规范未规定此区域的具体数据结构。然后再Java堆中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。加载阶段与连接阶段的部分内容是交替进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 2、验证 验证阶段虚拟机做了下面这些事情 1、文件格式验证 第一阶段是要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。会验证一下这些内容。 主、次版本号是否在当前虚拟机处理范围之内。常量池的常量中是否有不被支持的常量类型。指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。Class文件中各部分及文件本身是否有被删除的或附加的其他信息 2、元数据的验证 这个类是否有父类。这个类的父类是否继承了不允许被继承的类（即被final修饰的类）。若这个类不是抽象类，是否实现了其父类或接口之中要求的所有方法。 3、字节码的验证 这个阶段是验证最为复杂的一个阶段，主要工作是进行数据流和控制流分析，紧接第二阶段。 保证任意时刻操作数栈的数据类型与指令代码序列能配合工作。不会是在操作栈中放置了一个int类型的数据，使用时却按照long类型来加载。保证跳转指令不会跳转到方法体之外的字节码上。保证 方法体中的类型转换是有效。 4、符号引用验证 符号引用中通过字符串描述的全限定名是否能找到对应的类。在知道类中是否存在符合方法的字段描述符即简单名称所描述的方法和字段。符合引用中的类、字段和方法的访问级别是否可以被当前的类访问。3、准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，注意是初始值不是最终变量的值，都将在方法区中进行分配。如果该变量不是静态变量，将不会进行内存分配，而是会在类出乎实话的时候随着对象一起分配到Java堆中。另外这里的初始值通常情况下是零值。具体的初始化的值见下图，图片来源于《深入理解Jvm虚拟机》。 4、解析 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用于虚拟机实现内存布局无关，引用的目标不一定已经加载到内存中。 直接引用：直接引用可以使直接指向目标的指针、相对偏移量是一个能间接定位到目标的句柄。 5、初始化 类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全有虚拟机主导和空值。到了初始化阶段，才真正开始执行类中定义的Java程序代码。 前面讲到在准备阶段变量已经富余过一次初始值，而在初始化阶段，则是根据程序员通过程序制定主观计划去初始化变量和其他资源。 三、初始化阶段补充 一下四中情况会必须立即对类进行“初始化”。 遇到new、getstatic、putstatic或invokestatic者4调字节码指令时，如果类每一进行过初始化，则需要先触发器初始化。使用反射调用一个对象的时候，该对象必须初始化当初始化一个类的时候发现其父类没有初始化，则对其父类先初始化当虚拟机启动的时候，用户需要知道一个要执行的主类（即包含main（）方法的那个类），虚拟机会先初始化这个主类。 除了上面4中场景，都不会触发初始化，称为被动引用。 场景一 12345678910111213141516171819public class SupClass &#123; public static int value = 100; static&#123; System.out.println(&quot;SupClass init...&quot;); &#125; &#125;public class SubClass extends SupClass &#123; static&#123; System.out.println(&quot;SubClass init...&quot;); &#125; &#125; 客户端代码 1234567public class InitTest &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125; &#125; 输出如下12SupClass init...100 可以看到通过子类引用父类的静态字段，不会导致子类初始化。 场景二 其他代码同场景一，客户端代码变成如下 1234567public class InitTest &#123; public static void main(String[] args) &#123; SupClass[] sca = new SupClass[10]; &#125; &#125; 这段代码不会输出任何结果。因为通过数组定义来引用类，不会触发此类的初始化。 场景三 123456789public class ConstClass &#123; public static final String HELLO = &quot;hello&quot;; static&#123; System.out.println(&quot;ConstClass init...&quot;); &#125; &#125; 客户端代码 1234567public class InitTest &#123; public static void main(String[] args) &#123; System.out.println(ConstClass.HELLO); &#125; &#125; 输出如下12hello 可以看到常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 四、总结本篇文章依据以下两点 在实际情况中，每个class文件都有可能代表着Java语言中的一个类或者接口，而对于类和接口需要分开描述笔者所讲的“Class文件”并非指class必须是存在于具体磁盘中的某个文件，这里说的class文件指的是一种二进制字节流，无论以何种形式存在都可以。]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2017%2F07%2F28%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、什么是模板方法模式 概念：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，模板方法模式是通过把不变行为搬到超类，去除子类里面的重复代码提现它的优势，它提供了一个很好的代码复用平台。当不可变和可变的方法在子类中混合在一起的时候，不变的方法就会在子类中多次出现，这样如果摸个方法需要修改则需要修改很多个，虽然这个这个问题在设计之初就应该想好。这个时候模板方法模式就起到了作用了，通过模板方法模式把这些重复出现的方法搬到单一的地方，这样就可以帮助子类摆脱重复不变的纠缠。 举个好懂的例子，小时候笔者家里穷，在农村上小学的时候考试都是每个学生手抄试卷，因为那个时候学校还没有试卷印刷。全班五十多个学生每个学生都要重复抄一遍黑板的试卷，并且像笔者这样的近视眼很容易就抄错了，8抄成3,7抄成1等到，然后明明做对了但是分数就是不高，导致笔者一直是全班倒数。这就是个很严重的重复不可变的问题，现在条件好了不少，学生不需要抄试卷，试卷印刷就解决了这个重复抄试卷的问题。模板方法也是类似。 二、模式对比1、抄试卷模式笔者就以抄试卷模式为名来阐述重复不变带来的不便，下面会对该模式进行改进。 学生甲抄的试卷 12345678910111213141516171819public class TestPaperA &#123; //试卷第一题 public void testQuestion1()&#123; System.out.println(&quot;小龙女是杨过的什么亲戚？() A.小姨妈 B.大姨妈 C.姑妈 D.舅妈&quot;); System.out.println(&quot;答案：C&quot;); &#125; //试卷第二题 public void testQuestion2()&#123; System.out.println(&quot;全真教的首任掌门是谁？A.周伯通 B.欧阳锋 C.王重阳 D.西门吹牛&quot;); System.out.println(&quot;答案：C&quot;); &#125; //试卷第三题 public void testQuestion3()&#123; System.out.println(&quot;《天龙八部》中被封为南院大王的大侠是谁？A.段誉 B.乔峰 C.慕容复 D.段智兴&quot;); System.out.println(&quot;答案：B&quot;); &#125;&#125; 学生乙抄的试卷 12345678910111213141516171819public class TestPaperB &#123; //试卷第一题 public void testQuestion1()&#123; System.out.println(&quot;小龙女是杨过的什么亲戚？() A.小姨妈 B.大姨妈 C.姑妈 D.舅妈&quot;); System.out.println(&quot;答案：A&quot;); &#125; //试卷第二题 public void testQuestion2()&#123; System.out.println(&quot;全真教的首任掌门是谁？A.周伯通 B.欧阳锋 C.王重阳 D.西门吹牛&quot;); System.out.println(&quot;答案：C&quot;); &#125; //试卷第三题 public void testQuestion3()&#123; System.out.println(&quot;《天龙八部》中被封为南院大王的大侠是谁？A.段誉 B.乔峰 C.慕容复 D.段智兴&quot;); System.out.println(&quot;答案：D&quot;); &#125;&#125; 客户端代码 12345678910111213141516public class ShowAnswer &#123; public static void main(String[] args) &#123; System.out.println(&quot;学生甲的试卷&quot;); TestPaperA stuA = new TestPaperA(); stuA.testQuestion1(); stuA.testQuestion2(); stuA.testQuestion3(); System.out.println(&quot;学生乙的试卷&quot;); TestPaperB stuB = new TestPaperB(); stuB.testQuestion1(); stuB.testQuestion2(); stuB.testQuestion3(); &#125;&#125; 很容易发现上面两个学生抄的试卷有很多重复的地方，比如试卷的题目，输出答案的方法，这些都在每个学生试卷类中混合在一起了，既不利于维护，也不利于浏览，下面看一下模板方法模式是怎么改进的。 2、模板方法模式将每个学生试卷的重复部分提取出来，题目，作答等等。 首先改造试卷类，将该类改为抽象类，在该类中我添加了三个抽象的方法用于子类实现，学生都是要作答的，但是答案不一样，所以可以将作答的过程作为重复不变的方法提取出来，代码如下。 12345678910111213141516171819202122232425262728293031public abstract class TestPaper &#123; //试卷第一题 public void testQuestion1()&#123; System.out.println(&quot;小龙女是杨过的什么亲戚？() A.小姨妈 B.大姨妈 C.姑妈 D.舅妈&quot;); System.out.println(&quot;答案：&quot; + answer1()); &#125; //试卷第二题 public void testQuestion2()&#123; System.out.println(&quot;全真教的首任掌门是谁？A.周伯通 B.欧阳锋 C.王重阳 D.西门吹牛&quot;); System.out.println(&quot;答案：&quot; + answer2()); &#125; //试卷第三题 public void testQuestion3()&#123; System.out.println(&quot;《天龙八部》中被封为南院大王的大侠是谁？A.段誉 B.乔峰 C.慕容复 D.段智兴&quot;); System.out.println(&quot;答案：&quot; + answer3()); &#125; //这三个钩子方法是给每个子类去实现，并返回答案的 public abstract String answer1(); public abstract String answer2(); public abstract String answer3(); //模板方法，考试的过程，定义基本的考试过程，子类回调 public void exam()&#123; testQuestion1(); testQuestion2(); testQuestion3(); &#125;&#125; 首先来看第一个学生的考试情况 123456789101112131415161718public class TestPaperA extends TestPaper&#123; @Override public String answer1() &#123; return &quot;A&quot;; &#125; @Override public String answer2() &#123; return &quot;B&quot;; &#125; @Override public String answer3() &#123; return &quot;D&quot;; &#125; &#125; 其他学生的试卷可能答案不是一样的，但是基本的答题过程就是一样的，所以就不重复写了，下面看下客户端代码。 12345678public class ShowAnswer &#123; public static void main(String[] args) &#123; TestPaper testPaper = new TestPaperA(); testPaper.exam(); &#125;&#125; 可以看待客户端代码也减轻了很多，这样逻辑清晰，利于维护，优势很明显，下面看下具体答题情况。123456小龙女是杨过的什么亲戚？() A.小姨妈 B.大姨妈 C.姑妈 D.舅妈答案：A全真教的首任掌门是谁？A.周伯通 B.欧阳锋 C.王重阳 D.西门吹牛答案：B《天龙八部》中被封为南院大王的大侠是谁？A.段誉 B.乔峰 C.慕容复 D.段智兴答案：D 3、模板方法模式的基本结构AbstractClass是一个抽象类，其实就是一个抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体的实现，他给出了一些逻辑的骨架，而逻辑的组成在相应的抽象类中，推迟到了子类实现。代码如下 12345678910111213public abstract class AbstractClass &#123; //一些抽象行为，可以理解为重复不变的方法，提取到抽象类 public abstract void primitiveOperation1(); public abstract void primitiveOperation2(); //模板方法，给出了具体逻辑的骨架，而逻辑的组成是一些相应的抽象操作，他们都推迟到子类实现 public void templateMothed()&#123; primitiveOperation1(); primitiveOperation2(); &#125; &#125; ConcreteClass，实现父类所定义的一个或多个抽象方法。每一个AbstractClass都可以有一个或者多个ConcreteClass与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是骨架的组成步骤）的不同实现，从而得到的实现都不同。 12345678910111213public class ConcreteClassA extends AbstractClass&#123; @Override public void primitiveOperation1() &#123; System.out.println(&quot;子类Ａ的操作１&quot;); &#125; @Override public void primitiveOperation2() &#123; System.out.println(&quot;子类Ａ的操作２&quot;); &#125;&#125; 12345678910111213public class ConcreteClassB extends AbstractClass&#123; @Override public void primitiveOperation1() &#123; System.out.println(&quot;子类Ｂ的操作１&quot;); &#125; @Override public void primitiveOperation2() &#123; System.out.println(&quot;子类Ｂ的操作２&quot;); &#125;&#125; 上面定义了两个具体的实现，更多的实现其实都是一致的，这里就不多多说了。下面看下客户端代码 1234567891011public class Show &#123; public static void main(String[] args) &#123; AbstractClass c; c = new ConcreteClassA(); c.templateMothed(); c = new ConcreteClassB(); c.templateMothed(); &#125; &#125; 输入如下1234子类Ａ的操作１子类Ａ的操作２子类Ｂ的操作１子类Ｂ的操作２ 4、UML图 三、总结 模板方法模式就是为了将重复不变的代码提取到一个抽象类中。当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java垃圾回收机制]]></title>
    <url>%2F2017%2F07%2F28%2F%E6%B5%85%E8%B0%88java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、问题 笔者最近遇到超级多的关于java中垃圾回收机制的问题，所以特地写一遍博客来和大家交流一下java中的垃圾回收到底是什么鬼。所谓垃圾回收即使jvm觉得你这个对象没有存在的必要，将你清理出去，那么问题来了。 如何确定某个对象是需要被回收？ 典型的垃圾收集算法，是怎么回收对象的？ 典型的垃圾收集器有哪些？ 依次来看看这些问题！！！ 二、如何确定某个对象是需要被回收的 这里我们先了解一个的问题：如果确定某个对象是“垃圾”？既然垃圾收集器的任务是回收垃圾对象所占的空间供新的对象使用，那么垃圾收集器如何确定某个对象是“垃圾”？—即通过什么方法判断一个对象可以被回收了。有些对象是jvm内存不足需要清理内存空间，会将下一轮需要回收的对象进行清理。 在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。 这样的方法简单粗暴，而且效率很高。效率高必然会暴露一些问题，如果某些对象呗循环引用，即使你把对象赋值为null，这种算法照样不能回收。看下下面的代码 12345678910111213141516public class GcTest &#123; public Object object = null; public static void main(String[] args) &#123; GcTest gcTest1 = new GcTest(); GcTest gcTest2 = new GcTest(); gcTest1.object = gcTest1; gcTest2.object = gcTest2; gcTest1 = null; gcTest2 = null; &#125;&#125; 虽然gcTest1，gcTest2是null，他们指向的对象已经不会被访问到了，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。 上面的问题已经暴露出来了，下面看看jvm是怎么解决这个问题的。为了解决这个问题，在Java中采取了可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。在《深入理解jvm》讲解的很仔细，笔者就简单介绍下GC Roots的概念，想深入了解的可以去读下笔者介绍的这本书。 以下三类对象在jvm中作为GC roots，来判断一个对象是否可以被回收 (通常来说我们只要知道虚拟机栈和静态引用就够了) 1、虚拟机栈(JVM stack)中引用的对象(准确的说是虚拟机栈中的栈帧(frames)) 。我们知道，每个方法执行的时候，jvm都会创建一个相应的栈帧(栈帧中包括操作数栈、局部变量表、运行时常量池的引用)，栈帧中包含这在方法内部使用的所有对象的引用(当然还有其他的基本类型数据)，当方法执行完后，该栈帧会从虚拟机栈中弹出，这样一来，临时创建的对象的引用也就不存在了，或者说没有任何gc roots指向这些临时对象，这些对象在下一次GC时便会被回收掉 2、方法区中类静态属性引用的对象 。静态属性是该类型(class)的属性，不单独属于任何实例，因此该属性自然会作为gc roots。只要这个class存在，该引用指向的对象也会一直存在。class 也是会被回收的，在面后说明 3、本地方法栈(Native Stack)引用的对象 下面介绍下关于软引用（softReference）和弱引用（weakReference）的对象垃圾回收对他们做的处理123String str = new String(&quot;hello&quot;);//ASoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;java&quot;));//BWeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt;(new String(&quot;world&quot;));//C 上面的几个对象中回收情况如下，B在内存不足的情况下会将String对象判定为可回收对象，C无论什么情况下String对象都会被判定为可回收对象。也就是说软引用会在内存溢出（OOM）的时候回收，而弱引用无论什么情况都会在下一轮回收的时候回收掉。 一般jvm会对这些对象回收 1、显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象。 2、局部引用所指向的对象。 3、上面说的弱引用（weakReference）。 三、垃圾收集算法 在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，就以最常用的HotShot为例，所以在此只讨论几种常见的垃圾收集算法的核心思想。 1、Mark-Sweep（标记-清除）算法 这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。图解来自网络，很好的说明了标记-清楚算法的处理前和处理后的内存分布。 下面所有的图是模拟内存块，红色为未使用内存块，灰色为待回收对象内存块，黄色为存活对象 回收之前 回收之后 很容易看出这样的操作是有弊端的，这样讲标记的对象的清楚后，内存块就变的零零散散，如果现在有一个对象占用的内存很大，这个时候必须要在执行一遍垃圾回收，为这个大的对象腾出空间。 2、Copying（复制）算法 为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。 回收之前 回收之后 复制算法会提前空出一般的内存，在垃圾回收的时候将存活的对象移动的另外一半内存，这样内存的移动消耗太大，虽然内存不是零散的，但是代价太高。 3、Mark-Compact（标记-整理）算法 为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示： 回收之前 回收之后 4、Generational Collection（分代收集）算法 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，并不是回收所有，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。可以调用System.gc()方法查看回收情况。 目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。 而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。 注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。 三、典型的垃圾收集器 下面都是些概率性的东西，笔者看得也似懂非懂，直接搬过来分享给大家 1.Serial/Serial Old : Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。 2.ParNew : ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。 3.Parallel Scavenge : Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。 4.Parallel Old : Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。 5.CMS : CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。 6.G1 : G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。 四、总结和补充 对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。 一般来说，大对象会被直接分配到老年代，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如： byte[] data = new byte[410241024] 这种一般会直接在老年代分配存储空间。 当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式]]></title>
    <url>%2F2017%2F07%2F28%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、什么是装饰模式 概念：动态的给一个对象添加一些额外的功能。就增加功能来说，装饰模式比生成自子类更加的灵活。 举个例子，笔者自己以前喜欢吃手抓饼。每天都要去十字路口大爷那里买手抓饼，但是大爷卖的手抓饼有大份，小份等等，还有各种口味的配料添加。比如我比较喜欢变态辣，喜欢加火腿，喜欢加鸡蛋，所以每次去买手抓饼都会在最基础的手抓饼上加上”装饰”，让他变成豪华版手抓饼，这其实就是装饰模式的一个体现。 二、装饰模式详解1、手抓饼模式手抓饼其实就是一个组件(Component)，之后会有很多的装饰类(Decorate)对它进行装饰，比如加鸡蛋，变态辣等等。 Cookie类，组件接口，仅仅包含一个售价方法，cost() public interface Cookie { public double cost(); }BigCookie类，大份手抓饼，具体的手抓饼实现类 12345678public class BigCookie implements Cookie &#123; @Override public double cost() &#123; return 6.0; &#125;&#125; BatchCookie类，装饰的抽象类，此处演示并没有将它设为抽象 12345678910111213public class BatchCookie implements Cookie &#123; private Cookie cookie; public BatchCookie(Cookie cookie)&#123; this.cookie = cookie; &#125; @Override public double cost() &#123; return cookie.cost(); &#125;&#125; AddEgg类，AddHam类都是继承了BatchCookie类，为具体的装饰方法，加鸡蛋加两元，加火腿加一块 123456789101112public class AddEgg extends BatchCookie &#123; public AddEgg(Cookie cookie) &#123; super(cookie); &#125; @Override public double cost() &#123; return super.cost() + 2; &#125;&#125; 12345678910111213public class AddHam extends BatchCookie &#123; public AddHam(Cookie cookie) &#123; super(cookie); &#125; @Override public double cost() &#123; // TODO Auto-generated method stub return super.cost() + 1; &#125;&#125; 客户端代码 1234567891011121314public class Show2 &#123; public static void main(String[] args) &#123; Cookie cookie = new BigCookie(); cookie = new AddEgg(cookie); cookie = new AddHam(cookie); double money = cookie.cost(); System.out.println(&quot;大份手抓饼加鸡蛋加火腿一起&quot; + money + &quot;元&quot;); &#125;&#125; 测试结果 大份手抓饼加鸡蛋加火腿一起9.0元可以看到手抓饼可以加鸡蛋加火腿，手抓饼被装饰了，原本普通的手抓饼添加了新的功能，而这就是装饰模式的最直接的体现，接下来看看装饰模式的具体结果。 2、装饰模式具体结构Component类，组件抽象类，被装饰对象的抽象类 public abstract class Component { public abstract void opreate(); }ConcreteComponent类，具体的组件实现类，也可以对该对象进行动态的装饰，即添加新功能 12345678public class ConcreteComponent extends Component &#123; @Override public void opreate() &#123; System.out.println(&quot;具体对象的操作&quot;); &#125;&#125; Decorate类，装饰的抽象类，也继承了Component对象 12345678910111213141516171819202122public class Decorate extends Component &#123; private Component component; public Component getComponent() &#123; return component; &#125; //设置Component public void setComponent(Component component) &#123; this.component = component; &#125; //重写operate()，实际执行的是component的operate() @Override public void opreate() &#123; if (component != null) &#123; component.opreate(); &#125; &#125;&#125; ConcreteDecorateA类，具体的装饰类，实现了Decorate类，并提供了该装饰对象独特的装饰方法 1234567891011121314151617181920public class ConcreteDecorateA extends Decorate &#123; //本类独有的装饰功能，区别于ConcreteDecorateB private String addedState; public String getAddedState() &#123; return addedState; &#125; public void setAddedState(String addedState) &#123; this.addedState = addedState; &#125; @Override public void opreate() &#123; super.opreate(); this.addedState = &quot;New State&quot;; System.out.println(&quot;具体装饰对象A的操作&quot;); &#125;&#125; ConcreteDecorateB类，也提供了该对象独特的装饰方法 12345678910111213public class ConcreteDecorateB extends Decorate &#123; private void addedBehavior()&#123; System.out.println(&quot;装饰类B添加行为&quot;); &#125; @Override public void opreate() &#123; super.opreate(); System.out.println(&quot;具体装饰对象B的操作&quot;); addedBehavior(); &#125;&#125; 客户端代码 1234567891011121314151617public class Show &#123; //首先用ConcreteComponent实例对象component，然后用ConcreteDecorateA //对象d1来包装component，再用ConcreteDecorateB对象d2来包装d1，最后是用 //d2执行opreate() public static void main(String[] args) &#123; ConcreteComponent component = new ConcreteComponent(); ConcreteDecorateA d1 = new ConcreteDecorateA(); ConcreteDecorateB d2 = new ConcreteDecorateB(); d1.setComponent(component); d2.setComponent(d1); d2.opreate(); &#125;&#125; 测试结果12345具体对象的操作具体装饰对象A的操作具体装饰对象B的操作装饰类B添加行为上面就是装饰模式的节本构造，虽然不是很好懂，但是结合实际生活的场景就很容易理解。 3、UML图 三、总结 Component是定义一个对象接口，可以给这些对象动态的添加功能。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些功能。Decorate类，装饰抽象类，也继承了从外来类扩展Component的功能，但是对于Component来说，没有必要知道Decorate的存在。至于ConcreteDecorate就是具体的装饰对象，起到了给Component添加功能的作用。 装饰模式是为已有的功能动态的添加更多功能的一种方式。当系统需要添加新功能的时候，是向旧的类中添加新代码，这是设计之初的想法，但是严重违反了开放-封闭原则，这些新加的功能严重和原有的类耦合在一起了，因为新加入的功仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。但是装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户端代码就可以在运行时根据需要有选择的、按顺序的使用装饰功能的包装对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm中的内存分配]]></title>
    <url>%2F2017%2F07%2F28%2Fjvm%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[一、导论 java技术体系中所提到的内存自动化管理归根结底就是内存的分配与回收两个问题，之前已经和大家谈过java回收的相关知识，今天来和大家聊聊java对象的在内存中的分配。通俗的讲，对象的内存分配就是在堆上的分配，对象主要分配在新生代的Eden上（关于对象在内存上的分代在垃圾回收中会补上，想了解的也可以参考《深入理解java虚拟机》），如果启动了本地线程分配缓冲，讲按线程优先在TLAB上分配。少数情况下也是直接在老年代中分配。 二、经典的分配策略1、对象优先在Eden上分配 一般情况下对象都是优先分配在Eden上，当Eden没有足够的空间进行分配时，jvm会发起一次Minor GC。如果还是没有足够的空间分配，后面还有另外的措施，下面会提到。 设置虚拟机的偶记日志参数-XX:+PrintGCDetails，在垃圾回收的时候会打印内存的回收日志，并且在进程退出的时候会输出当前内存各区域的分配情况。下面来看下具体的例子，首先需要设置jvm的参数-Xms20m -Xmx20m -Xmn10m，这三个参数说明java堆大小为20M，且不可扩展，其中10M分配给新生代，剩下的10M分配给老年代。-XX:SurvivorRatio=8是jvm默认的新生代中Eden和Survivor比例，默认为8:1。原因是新生代中的对象98%都会在下一次GC的时候回收掉，所以很适合采用复制算法进行垃圾回收，所以新生代10M的内存中，8M是Eden，1M是Survivor，另外的1M是未使用配合复制算法的内存块，也是Survivor。 1234567891011121314151617 1 public class ReflectTest &#123; 2 3 private static final int _1MB = 1024*1024; 4 5 public static void testAllocation()&#123; 6 byte[] allocation1 , allocation2 , allocation3 , allocation4; 7 allocation1 = new byte[2 * _1MB]; 8 allocation2 = new byte[2 * _1MB]; 9 allocation3 = new byte[2 * _1MB];10 allocation4 = new byte[6 * _1MB];11 &#125;12 13 public static void main(String[] args) &#123;14 ReflectTest.testAllocation();15 &#125;16 17 &#125; 输出如下 123456789Heap PSYoungGen total 9216K, used 6651K [0x000000000b520000, 0x000000000bf20000, 0x000000000bf20000) eden space 8192K, 81% used [0x000000000b520000,0x000000000bb9ef28,0x000000000bd20000) from space 1024K, 0% used [0x000000000be20000,0x000000000be20000,0x000000000bf20000) to space 1024K, 0% used [0x000000000bd20000,0x000000000bd20000,0x000000000be20000) PSOldGen total 10240K, used 6144K [0x000000000ab20000, 0x000000000b520000, 0x000000000b520000) object space 10240K, 60% used [0x000000000ab20000,0x000000000b120018,0x000000000b520000) PSPermGen total 21248K, used 2973K [0x0000000005720000, 0x0000000006be0000, 0x000000000ab20000) object space 21248K, 13% used [0x0000000005720000,0x0000000005a07498,0x0000000006be0000) 可以看到eden占用了81%，说明allocation1 , allocation2 , allocation3 都是分配在新生代Eden上。 2、大对象直接分配在老年代上 大对象是指需要大量连续内存空间去存放的对象，类似于那种很长的字符串和数组。大对象对于虚拟机的内存分布来讲并不是好事，当遇到很多存活仅一轮的大对象jvm更加难处理，写代码的时候应该避免这样的问题。虚拟机中提供了-XX:PretenureSizeThreshold参数，另大于这个值的对象直接分配到老年代，这样做的目的是为了避免在Eden区和Survivor区之间发生大量的内存copy，在之前讲过的垃圾回收算法复制算法有提到过，就不多说了。 12345678910111213141516public class ReflectTestBig &#123; private static final int _1MB = 1024*1024; public static void testAllocation()&#123; byte[] allocation2 , allocation3 , allocation4; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; allocation4 = new byte[6 * _1MB]; &#125; public static void main(String[] args) &#123; ReflectTestBig.testAllocation(); &#125; &#125; 输出如下 123456789Heap PSYoungGen total 8960K, used 4597K [0x000000000b510000, 0x000000000bf10000, 0x000000000bf10000) eden space 7680K, 59% used [0x000000000b510000,0x000000000b98d458,0x000000000bc90000) from space 1280K, 0% used [0x000000000bdd0000,0x000000000bdd0000,0x000000000bf10000) to space 1280K, 0% used [0x000000000bc90000,0x000000000bc90000,0x000000000bdd0000) PSOldGen total 10240K, used 6144K [0x000000000ab10000, 0x000000000b510000, 0x000000000b510000) object space 10240K, 60% used [0x000000000ab10000,0x000000000b110018,0x000000000b510000) PSPermGen total 21248K, used 2973K [0x0000000005710000, 0x0000000006bd0000, 0x000000000ab10000) object space 21248K, 13% used [0x0000000005710000,0x00000000059f7460,0x0000000006bd0000) 可以看到allocation4已经超过了设置的-XX:PretenureSizeThreshold=3145728，随意allocation4直接被分配到了老年代，老年代占用率为60%。注意这里设置-XX:PretenureSizeThreshold=3145728不能写成-XX:PretenureSizeThreshold=3m，否则jvm将无法识别。 3、长期存活的对象将进入老年代 虚拟机既然采用了分带收集的思想来管理内存，那内存回收就必须识别哪些对象应该放在新生代，哪些对象应该放在老年代。为了打到目的，jvm给每个对象定义了一个年龄计数器（Age）。如果对象在Eden出生并且能过第一次Minor GC后仍然存活，并且可以在Survivor存放的话，将被移动到Survivor中，并将对象的年龄设为1。对象每躲过一次Minor GC，年龄就会加1，当他的年龄超过一年的阈值的时候，该对象就会晋升到老年代。这个阈值jvm默认是15，可以通过-XX:MaxTenuringThreshold来设置。 123456789101112public class JavaTest &#123; static int m = 1024 * 1024; public static void main(String[] args) &#123; byte[] a1 = new byte[1 * m / 4]; byte[] a2 = new byte[7 * m]; byte[] a3 = new byte[3 * m]; //GC &#125; &#125; 输出如下 1234567891011121314[GC [DefNew: 7767K-&gt;403K(9216K), 0.0062209 secs] 7767K-&gt;7571K(19456K), 0.0062482 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] a3 ok Heap def new generation total 9216K, used 3639K [0x331d0000, 0x33bd0000, 0x33bd0000) eden space 8192K, 39% used [0x331d0000, 0x334f9040, 0x339d0000) from space 1024K, 39% used [0x33ad0000, 0x33b34de8, 0x33bd0000) to space 1024K, 0% used [0x339d0000, 0x339d0000, 0x33ad0000) tenured generation total 10240K, used 7168K [0x33bd0000, 0x345d0000, 0x345d0000) the space 10240K, 70% used [0x33bd0000, 0x342d0010, 0x342d0200, 0x345d0000) compacting perm gen total 12288K, used 381K [0x345d0000, 0x351d0000, 0x385d0000) the space 12288K, 3% used [0x345d0000, 0x3462f548, 0x3462f600, 0x351d0000) ro space 10240K, 55% used [0x385d0000, 0x38b51140, 0x38b51200, 0x38fd0000) rw space 12288K, 55% used [0x38fd0000, 0x396744c8, 0x39674600, 0x39bd0000) 可以看到a2已经存活了一次，年龄为1，满足所设置的-XX:MaxTenuringThreshold=1，所以a2进入了老年代，而a3则进入了新生代。 4、动态对象年龄判定 为了能更好的适应不同程序的内存状态，虚拟机并不总是要求对象的年龄必须达到-XX:MaxTenuringThreshold所设置的值才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年区，无须达到-XX:MaxTenuringThreshold中的设置值。 5、空间分配担保 在发生Minor GC的时候，虚拟机会检测每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大于，则直接进行一次FUll GC。如果小于，则查看HandlerPromotionFailyre设置是否允许担保失败，如果允许那就只进行Minor GC，如果不允许则也要改进一次FUll GC。也就是说新生代Eden存不下改对象的时候就会将该对象存放在老年代。 三、常用的jvm参数设置1、-Xms： 初始堆大小， 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制。 2、Xmx： 最大堆大小，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。 3、-Xmn： 年轻代大小(1.4or lator)， 此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。 增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8。 4、-XX:NewSize： 设置年轻代大小(for 1.3/1.4)。 5、-XX:MaxNewSize： 年轻代最大值(for 1.3/1.4)。 6、-XX:PermSize： 设置持久代(perm gen)初始值。 7、-XX:MaxPermSize： 设置持久代最大值。 8、-Xss： 每个线程的堆栈大小，JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右。 9、-XX:NewRatio： 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)，-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5。Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 10、-XX:SurvivorRatio： Eden区与Survivor区的大小比值，设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10。 11、-XX:LargePageSizeInBytes： 内存页的大小不可设置过大， 会影响Perm的大小。 12、-XX:+DisableExplicitGC： 关闭System.gc() 13、-XX:MaxTenuringThreshold： 垃圾最大年龄，如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效。 14、-XX:PretenureSizeThreshold： 对象超过多大是直接在旧生代分配，单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象。 15、-XX:TLABWasteTargetPercent： TLAB占eden区的百分比。 四、补充Minor GC和FUll GC的区别： 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为java对象大对数都是逃不过第一轮的GC，所以Minor GC使用很频繁，一般回收速度也比较快。 老年代GC（FULL GC/Major GC） ：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对，在ParallelScavenge收集器的收集策略中就有直接进行Major GC的选择过程 ）。Major GC的速度一般会比Minor GC慢10倍以上。]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2017%2F07%2F28%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、什么是代理模式（Porxy） 概念：代理模式就是为其他对象提供一种代理以控制对这个对象的访问。 现实生活中也有很多行为吻合代理模式。比如店外卖，客户在APP上下单后，店长会接单。这个时候店长可以选择自己去送这份外卖，也可以委托送餐员代理店长去送这份外卖。当然店长是可以自己送，但店长送了外卖店就没人看着了，而让送餐员代理送外卖就不会这样了。这里很显然店长是对象本尊（Subject），送餐员是代理对象（Proxy ），代理对象中有店长给的订单信息，比如送到哪里，几点之前要送到，这就说明代理对象中需要包含本尊。下面根据实际代码来说明代理模式和非代理的具体实现。 二、模式对比1、非代理模式非代理模式即店长自己送，无须委托送餐员代理送。即直接创建本尊对象并访问本尊方法，没有中间的代理对象。 本尊代码 123456789101112131415public class ShopKeeper &#123; //客户信息 private Consumer consumer; public ShopKeeper(Consumer consumer)&#123; this.consumer = consumer; &#125; //外卖订单信息 public void send()&#123; System.out.println(consumer.getConName() + &quot;的订单,店长自己送，送到胶东路520弄，11:30之前送达...&quot;); &#125; &#125; 客户代码 123456789101112public class Consumer &#123; private String conName; public Consumer(String conName)&#123; this.conName = conName; &#125; public String getConName() &#123; return conName; &#125;&#125; 客户端测试代码 123456789public class Show &#123; public static void main(String[] args) &#123; Consumer consumer = new Consumer(&quot;Tom&quot;); ShopKeeper shopKeeper = new ShopKeeper(consumer); shopKeeper.send(); &#125; &#125; 这样店长和客户的代码就耦合在一起，不利于后期维护升级。再者店长和客户本来就不需要相互包含，他们之间是无状态的。像很多pub/sub的中间件，比如dubbo，activeMQ等等，他们都是基于消息的发布的订阅机制，生产者和消费者之间没有必要有状态交互，你消费者挂了我生产者还是继续生产消息，互不影响，其实很多技术都是想通的，这里和代理模式就和类似。下面来看看代理模式是怎么处理的。 2、代理模式提供了一个共有的送外卖接口 1234567public interface Send &#123; void sendName(); void sendTime(); void sendAddress(); &#125; 店长本尊对象，实现了共有的送外卖接口。 1234567891011121314151617181920212223242526/** * 店长对象（本尊）需要实现Send接口 * @author user */public class ShopKeeper implements Send&#123; private Consumer consumer; public ShopKeeper(Consumer consumer)&#123; this.consumer = consumer; &#125; @Override public void sendName() &#123; System.out.print(consumer.getConName() + &quot;的订单，&quot;); &#125; @Override public void sendTime() &#123; System.out.print(&quot;12:00之前送达，&quot;); &#125; @Override public void sendAddress() &#123; System.out.print(&quot;送到长岛路520弄，由代理对象配送...&quot;); &#125; 新增了代理对象，代理对象需要包含本尊，并且也要实现送外卖（Send）接口 1234567891011121314151617181920212223242526272829/** * 代理对象也需要实现Send接口 * @author user * */public class ProxySend implements Send&#123; private ShopKeeper shopKeeper; public ProxySend(Consumer consumer)&#123; this.shopKeeper = new ShopKeeper(consumer); &#125; @Override public void sendName() &#123; shopKeeper.sendName(); &#125; @Override public void sendTime() &#123; shopKeeper.sendTime(); &#125; @Override public void sendAddress() &#123; shopKeeper.sendAddress(); &#125;&#125; 客户对象没有变化 123456789101112public class Consumer&#123; private String conName; public String getConName() &#123; return conName; &#125; public void setConName(String conName) &#123; this.conName = conName; &#125;&#125; 客户端测试代码 1234567891011121314public class Show &#123; public static void main(String[] args) &#123; Consumer consumer = new Consumer(); consumer.setConName(&quot;外卖张&quot;); ProxySend proxy = new ProxySend(consumer); proxy.sendName(); proxy.sendTime(); proxy.sendAddress(); &#125; &#125; 看输出12外卖张的订单，12:00之前送达，送到长岛路520弄...这样代理对象就帮本尊完成了任务，可以看到客户端的代码变化很大，客户端根本不知道本尊的存在，因为在客户端代码中至始至终都没有看到本尊对象的创建，连实例都没有，这其实就是代理对象的作用之一，隐藏本尊。 3、代理模式基本结构Subject类，定义了RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy，这里使用抽象类12345public abstract class Subject &#123; public abstract void request(); &#125; RealSubject类，定义了Proxy所代表的真是实体 12345678public class RealSubject extends Subject &#123; @Override public void request() &#123; System.out.println(&quot;真实的请求&quot;); &#125;&#125; Proxy类，保存了一个引用使得代理对象可以访问实体对象，并提供一个与Subject的接口相同的接口，这样代理就可以用来代理实体。 12345678910111213public class Proxy extends Subject&#123; RealSubject realSubject; @Override public void request() &#123; if (realSubject == null) &#123; realSubject = new RealSubject(); &#125; realSubject.request(); &#125;&#125; 客户端代码 12345678public class Show &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.request(); &#125; &#125; 测试结果 真实的请求4、UML图 三、总结代理模式一般用在一下几种场合。1、远程代理，也就是为了一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。2、虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。3、安全代理，用来控制真实对象访问是的权限。4、智能指引，是指当前调用真实的对象时，代理处理另外一些事情。所以代理模式还算比较常用的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[concurrentHashMap源码阅读记录]]></title>
    <url>%2F2017%2F07%2F28%2F%E8%AF%B4%E8%AF%B4concurrentHashMap%2F</url>
    <content type="text"><![CDATA[一、导论这些天一直在看关于多线程和高并发的书籍，也对jdk中的并发措施了解了些许，看到concurrentHashMap的时候感觉知识点很乱，有必要写篇博客整理记录一下。 当资源在多线程下共享时会产生一些逻辑问题，这个时候类或者方法会产生不符合正常逻辑的结果，则不是线程安全的。纵观jdk的版本更新，可以看到jdk的开发人员在高并发和多线程下了很大的功夫，尽可能的通过jdk原生API来给开发人员带来最方便最轻松的高并发数据模型，甚至想完全为开发人员解决并发问题，可以看得出来jdk的开发人员确实很用心。但是在大量业务数据的逻辑代码的情况下高并发还是不可避免，也不可能完全通过jdk原生的并发API去解决这些并发问题，开发人员不得不自己去空值在高并发环境下的数据高可用性和一致性。 前面说了jdk原生的API已经有了很多的高并发产品，在java.util.concurrent包下有很多解决高并发，高吞吐量，多线程问题的API。比如线程池ThreadPoolExecutor，线程池工厂Executors，Future模式下的接口Future，阻塞队列BlockingQueue等等。 二、正文1、数据的可见性 直接进入正题，concurrentHashMap相信用的人也很多，因为在数据安全性上确实比HashMap好用，在性能上比hashtable也好用。大家都知道线程在操作一个变量的时候，比如i++，jvm执行的时候需要经过两个内存，主内存和工作内存。那么在线程A对i进行加1的时候，它需要去主内存拿到变量值，这个时候工作内存中便有了一个变量数据的副本，执行完这些之后，再去对变量真正的加1，但是此时线程B也要操作变量，并且逻辑上也是没有维护多线程访问的限制，则很有可能在线程A在从主内存获取数据并在修改的时候线程B去主内存拿数据，但是这个时候主内存的数据还没有更新，A线程还没有来得及讲加1后的变量回填到主内存，这个时候变量在这两个线程操作的情况下就会发生逻辑错误。 2、原子性 原子性就是当某一个线程A修改i的值的时候，从取出i到将新的i的值写给i之间线程B不能对i进行任何操作。也就是说保证某个线程对i的操作是原子性的，这样就可以避免数据脏读。 3、volatile的作用 Volatile保证了数据在多线程之间的可见性，每个线程在获取volatile修饰的变量时候都回去主内存获取，所以当线程A修改了被volatile修饰的数据后其他线程看到的一定是修改过后最新的数据，也是因为volatile修饰的变量数据每次都要去主内存获取，在性能上会有些牺牲。 4、措施 HashMap在多线程的场景下是不安全的，hashtable虽然是在数据表上加锁，纵然数据安全了，但是性能方面确实不如HashMap。那么来看看concurrentHashMap是如何解决这些问题的。 concurrentHashMap由多个segment组成，每一个segment都包含了一个HashEntry数组的hashtable， 每一个segment包含了对自己的hashtable的操作，比如get，put，replace等操作(这些操作与HashMap逻辑都是一样的，不同的是concurrentHashMap在执行这些操作的时候加入了重入锁ReentrantLock)，这些操作发生的时候，对自己的hashtable进行锁定。由于每一个segment写操作只锁定自己的hashtable，所以可能存在多个线程同时写的情况，性能无疑好于只有一个hashtable锁定的情况。通俗的讲就是concurrentHashMap由多个hashtable组成。 5、源码 看下concurrentHashMap的remove操作 123456789101112131415161718192021222324252627282930313233V remove(Object key, int hash, Object value) &#123; lock();//重入锁 try &#123; int c = count - 1; HashEntry&lt;K,V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); HashEntry&lt;K,V&gt; first = tab[index]; HashEntry&lt;K,V&gt; e = first; while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key))) e = e.next; V oldValue = null; if (e != null) &#123; V v = e.value; if (value == null || value.equals(v)) &#123; oldValue = v; // All entries following removed node can stay // in list, but all preceding ones need to be // cloned. ++modCount; HashEntry&lt;K,V&gt; newFirst = e.next; for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next) newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash, newFirst, p.value); tab[index] = newFirst; count = c; // write-volatile &#125; &#125; return oldValue; &#125; finally &#123; unlock();//释放锁 &#125; &#125; Count是被volatile所修饰，保证了count的可见性，避免操作数据的时候产生逻辑错误。segment中的remove操作和HashMap大致一样，HashMap没有lock()和unlock()操作。 看下concurrentHashMap的get源码 123456789101112131415161718V get(Object key, int hash) &#123; if (count != 0) &#123; // read-volatile HashEntry&lt;K,V&gt; e = getFirst(hash); //如果没有找到则直接返回null while (e != null) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; //由于没有加锁，在get的过程中，可能会有更新，拿到的key对应的value可能为null，需要单独判断一遍 V v = e.value; //如果value为不为null，则返回获取到的value if (v != null) return v; return readValueUnderLock(e); // recheck &#125; e = e.next; &#125; &#125; return null; &#125; 关于concurrentHashMap的get的相关说明已经在上面代码中给出了注释，这里就不多说了。 看下concurrentHashMap中的put public V put(K key, V value) { if (value == null) throw new NullPointerException(); int hash = hash(key.hashCode()); return segmentFor(hash).put(key, hash, value, false);}可以看到concurrentHashMap不允许key或者value为null 接下来看下segment的put 123456789101112131415161718192021222324252627282930V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; lock(); try &#123; int c = count; if (c++ &gt; threshold) // ensure capacity rehash(); HashEntry&lt;K,V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); HashEntry&lt;K,V&gt; first = tab[index]; HashEntry&lt;K,V&gt; e = first; while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key))) e = e.next; V oldValue; if (e != null) &#123; oldValue = e.value; if (!onlyIfAbsent) e.value = value; &#125; else &#123; oldValue = null; ++modCount; tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value); count = c; // write-volatile &#125; return oldValue; &#125; finally &#123; unlock(); &#125; &#125; 同样也是加入了重入锁，其他的基本和HashMap逻辑差不多。值得一提的是jdk8中添加的中的putval，这里就不多说了。 三、总结ConcurrentHashmap将数据结构分为了多个Segment，也是使用重入锁来解决高并发，讲他分为多个segment是为了减小锁的力度，添加的时候加了锁，索引的时候没有加锁，使用volatile修饰count是为了保持count的可见性，都是jdk为了解决并发和多线程操作的常用手段。]]></content>
      <categories>
        <category>java</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>集合</tag>
      </tags>
  </entry>
</search>